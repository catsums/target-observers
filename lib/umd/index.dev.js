/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["TargetObservers"] = factory();
	else
		root["TargetObservers"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@catsums/my/lib/umd/index.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@catsums/my/lib/umd/index.dev.js ***!
  \*******************************************************/
/***/ (function(module) {

eval("/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./lib/cjs/index.js\":\n/*!**************************!*\\\n  !*** ./lib/cjs/index.js ***!\n  \\**************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\neval(\"\\n\\nmodule.exports = __webpack_require__(/*! ./src */ \\\"./lib/cjs/src/index.js\\\");\\n\\n//# sourceURL=webpack://MY/./lib/cjs/index.js?\");\n\n/***/ }),\n\n/***/ \"./lib/cjs/src/index.js\":\n/*!******************************!*\\\n  !*** ./lib/cjs/src/index.js ***!\n  \\******************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\neval(\"\\n\\nvar MY = _interopRequireWildcard(__webpack_require__(/*! ./myHelperFunctions.js */ \\\"./lib/cjs/src/myHelperFunctions.js\\\"));\\nfunction _getRequireWildcardCache(nodeInterop) {\\n  if (typeof WeakMap !== \\\"function\\\") return null;\\n  var cacheBabelInterop = new WeakMap();\\n  var cacheNodeInterop = new WeakMap();\\n  return (_getRequireWildcardCache = function (nodeInterop) {\\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\\n  })(nodeInterop);\\n}\\nfunction _interopRequireWildcard(obj, nodeInterop) {\\n  if (!nodeInterop && obj && obj.__esModule) {\\n    return obj;\\n  }\\n  if (obj === null || typeof obj !== \\\"object\\\" && typeof obj !== \\\"function\\\") {\\n    return {\\n      default: obj\\n    };\\n  }\\n  var cache = _getRequireWildcardCache(nodeInterop);\\n  if (cache && cache.has(obj)) {\\n    return cache.get(obj);\\n  }\\n  var newObj = {};\\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\\n  for (var key in obj) {\\n    if (key !== \\\"default\\\" && Object.prototype.hasOwnProperty.call(obj, key)) {\\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\\n      if (desc && (desc.get || desc.set)) {\\n        Object.defineProperty(newObj, key, desc);\\n      } else {\\n        newObj[key] = obj[key];\\n      }\\n    }\\n  }\\n  newObj.default = obj;\\n  if (cache) {\\n    cache.set(obj, newObj);\\n  }\\n  return newObj;\\n}\\nmodule.exports = MY;\\n\\n//# sourceURL=webpack://MY/./lib/cjs/src/index.js?\");\n\n/***/ }),\n\n/***/ \"./lib/cjs/src/myHelperFunctions.js\":\n/*!******************************************!*\\\n  !*** ./lib/cjs/src/myHelperFunctions.js ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, exports) => {\n\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", ({\\n  value: true\\n}));\\nexports.JSONobjectsAreEqual = JSONobjectsAreEqual;\\nexports.ajax = ajax;\\nexports.ajaxGET = ajaxGET;\\nexports.ajaxPOST = ajaxPOST;\\nexports.areSimilar = areSimilar;\\nexports.arrayRemove = arrayRemove;\\nexports.checkBootstrapMedia = checkBootstrapMedia;\\nexports.checkCookie = checkCookie;\\nexports.clog = clog;\\nexports.cout = cout;\\nexports.deepEqual = deepEqual;\\nexports.defectAllFormSubmits = defectAllFormSubmits;\\nexports.deg2rad = deg2rad;\\nexports.deleteCookie = deleteCookie;\\nexports.docReady = docReady;\\nexports.findItem = findItem;\\nexports.findItemIndex = findItemIndex;\\nexports.findItemObject = findItemObject;\\nexports.findItemObjectIndex = findItemObjectIndex;\\nexports.footstrapMediaQueries = void 0;\\nexports.forMediaQuery = forMediaQuery;\\nexports.formDataToJSON = formDataToJSON;\\nexports.getAverageFrom = getAverageFrom;\\nexports.getBase64 = getBase64;\\nexports.getCSSValueInPixels = getCSSValueInPixels;\\nexports.getClosestPathInCircle = getClosestPathInCircle;\\nexports.getCookie = getCookie;\\nexports.getFileBlob = getFileBlob;\\nexports.getFormData = getFormData;\\nexports.getObjectFromArray = getObjectFromArray;\\nexports.hardPush = hardPush;\\nexports.hash128 = hash128;\\nexports.hash32 = hash32;\\nexports.hash64 = hash64;\\nexports.hexadecimalID = hexadecimalID;\\nexports.isArray = isArray;\\nexports.isExternalURL = isExternalURL;\\nexports.isExternalURLFast = isExternalURLFast;\\nexports.isFunction = isFunction;\\nexports.isInRange = isInRange;\\nexports.isInfinity = isInfinity;\\nexports.isInt = isInt;\\nexports.isJSON = isJSON;\\nexports.isNumber = isNumber;\\nexports.isObject = isObject;\\nexports.isString = isString;\\nexports.jsonFix = jsonFix;\\nexports.link_is_external = link_is_external;\\nexports.loadHTMLtoObject = loadHTMLtoObject;\\nexports.logg = logg;\\nexports.mod = mod;\\nexports.myAjax = myAjax;\\nexports.mysql_real_escape_string = mysql_real_escape_string;\\nexports.objectToURLParams = objectToURLParams;\\nexports.parseURLParams = parseURLParams;\\nexports.processAjaxData = processAjaxData;\\nexports.pushHistoryState = pushHistoryState;\\nexports.rad2deg = rad2deg;\\nexports.randomCharFrom = randomCharFrom;\\nexports.randomID = randomID;\\nexports.randomId = randomId;\\nexports.randomItemFrom = randomItemFrom;\\nexports.randomString = randomString;\\nexports.rndInt = rndInt;\\nexports.roundTo = roundTo;\\nexports.safeDivide = safeDivide;\\nexports.safeStringify = safeStringify;\\nexports.sanitizeString = sanitizeString;\\nexports.setCookie = setCookie;\\nexports.setHistoryState = setHistoryState;\\nexports.shallowEqual = shallowEqual;\\nexports.splitStringByLength = splitStringByLength;\\nexports.stepify = stepify;\\nexports.stringTrimToLength = stringTrimToLength;\\nexports.submitForm = submitForm;\\nexports.validateEmail = validateEmail;\\n/*myHelperModule.js*/\\n///FOR WEB API FRONT-END MODULES\\n\\n///CONSOLE///\\nfunction cout(...vars) {\\n  console.log(...vars);\\n}\\nfunction clog(...x) {\\n  console.log(...x);\\n}\\n\\n///OBJECT MODIFICATION///\\ntry {\\n  if (typeof Storage !== 'undefined') {\\n    Storage.prototype.setObject = function (key, value) {\\n      this.setItem(key, JSON.stringify(value));\\n    };\\n    Storage.prototype.getObject = function (key) {\\n      var value = this.getItem(key);\\n      return value && JSON.parse(value);\\n    };\\n  }\\n} catch (err) {\\n  console.debug(err);\\n}\\nArray.prototype.midCeil = function () {\\n  return this[Math.ceil(this.length / 2)];\\n};\\nArray.prototype.midFloor = function () {\\n  return this[Math.floor(this.length / 2)];\\n};\\nArray.prototype.midRound = function () {\\n  return this[Math.round(this.length / 2)];\\n};\\nArray.prototype.last = function () {\\n  return this[this.length - 1];\\n};\\nArray.prototype.first = function () {\\n  return this[0];\\n};\\nArray.prototype.removeAt = function (index) {\\n  return this.splice(index, 1);\\n};\\nArray.prototype.removeItem = function (item) {\\n  let ind = this.indexOf(item);\\n  return this.splice(ind, 1) > 0;\\n};\\nBigInt.prototype.toJSON = function () {\\n  return this.toString();\\n};\\n\\n///MOD\\n\\n///note that % operator in js is the Remainder operator and not Modulus\\n///:. (-1 % 5) gives -1 and not 4 as expected with modulus\\n\\nNumber.prototype.mod = function (n) {\\n  return (this % n + n) % n;\\n};\\nfunction mod(n, m) {\\n  return (n % m + m) % m;\\n}\\n\\n///Safe Division\\nfunction isInfinity(x) {\\n  return x === -Infinity || x === Infinity;\\n}\\nfunction safeDivide(a, b, useNaN = false) {\\n  let INF = Infinity;\\n  let res;\\n  if (a == 0 && b == 0) {\\n    if (useNaN) res = NaN;else res = 0;\\n  } else if (a == 0 && isInfinity(b)) {\\n    res = 0 * 1;\\n  } else if (isInfinity(a) && b == 0) {\\n    res = a * 1;\\n  } else if (isInfinity(a) && isInfinity(b)) {\\n    if (useNaN) res = NaN;else if (a == b) res = 1;else res = -1;\\n  } else if (b == 0) {\\n    if (useNaN) res = NaN;\\n    res = INF * a;\\n  } else if (isInfinity(b)) {\\n    if (useNaN) res = NaN;\\n    res = 0 * a;\\n  } else {\\n    res = a / b;\\n  }\\n  return res;\\n}\\nfunction getAverageFrom(arr) {\\n  if (!isArray(arr)) return null;\\n  if (!arr.length) return 0;\\n  let sum = arr.reduce((_sum, x) => {\\n    return _sum + x;\\n  }, 0);\\n  return sum / arr.length;\\n}\\n\\n///CSS///\\n\\nfunction getCSSValueInPixels(str) {\\n  let num = 0;\\n  let val = parseFloat(str);\\n  let unit = str.replace(`${val}`, '').trim();\\n  switch (unit) {\\n    case 'in':\\n      num = val * 96;\\n      break;\\n    case 'cm':\\n      num = val / 2.54 * 96;\\n      break;\\n    case 'mm':\\n      num = val / 100 / 2.54 * 96;\\n      break;\\n    case 'pt':\\n      num = val * 72 * 96;\\n      break;\\n    case 'pc':\\n      num = val * 12 * 72 * 96;\\n      break;\\n    default:\\n      //treat as px\\n      num = val;\\n      break;\\n  }\\n  return num;\\n}\\n\\n///OBJECT AND HTML///\\nfunction loadHTMLtoObject(query, url) {\\n  document.querySelector(query).setAttribute('data', url);\\n}\\nfunction docReady(fn) {\\n  // see if DOM is already available\\n  if (document.readyState === \\\"complete\\\" || document.readyState === \\\"interactive\\\") {\\n    // call on next available tick\\n    setTimeout(fn, 1);\\n  } else {\\n    document.addEventListener(\\\"DOMContentLoaded\\\", fn);\\n  }\\n}\\n\\n///MEDIA QUERIES///\\nlet footstrapMediaQueries = {\\n  xs: '0px',\\n  sm: '576px',\\n  md: '768px',\\n  lg: '992px',\\n  xl: '1200px',\\n  xxl: '1400px'\\n};\\nexports.footstrapMediaQueries = footstrapMediaQueries;\\nfunction forMediaQuery(mediaQuery, matchFunc, unmatchFunc) {\\n  let match = window.matchMedia(mediaQuery);\\n  if (match.matches) {\\n    matchFunc();\\n  } else {\\n    unmatchFunc();\\n  }\\n}\\nfunction checkBootstrapMedia() {\\n  // let qKeys = Object.keys(footstrapMediaQueries);\\n  let qVals = Object.values(footstrapMediaQueries);\\n  for (var c = qVals.length - 1; c >= 0; c--) {\\n    let qVal = qVals[c];\\n    let match = window.matchMedia(`(max-width: ${qVal})`);\\n    if (match.matches) return qKey;\\n  }\\n  return 'xs';\\n}\\n\\n///FORMS///\\nfunction getFormData(query) {\\n  let formElement;\\n  if (typeof query === 'string') formElement = document.querySelector(query);else if (query instanceof HTMLFormElement) formElement = query;else return null;\\n  let formData = new FormData(formElement);\\n  return formData;\\n}\\nfunction submitForm(query, callback, url) {\\n  let formElement = document.querySelector(query);\\n  let formData = new FormData(formElement);\\n  let methodType = formElement.getAttribute('method');\\n  ajax(formData, callback, url, methodType);\\n}\\nvar handleForm = e => {\\n  e.preventDefault();\\n  console.debug('Submit has been defected. Please use JS to override form submit');\\n};\\nfunction defectAllFormSubmits() {\\n  let allForms = document.getElementsByTagName('form');\\n  for (var form of allForms) {\\n    form.submit = () => {};\\n    form.addEventListener('submit', handleForm);\\n  }\\n}\\nfunction formDataToJSON(formData, stringify = false) {\\n  let object = {};\\n  formData.forEach((value, key) => {\\n    // Reflect.has in favor of: object.hasOwnProperty(key)\\n    if (!Reflect.has(object, key)) {\\n      object[key] = value;\\n      return;\\n    }\\n    if (!Array.isArray(object[key])) {\\n      object[key] = [object[key]];\\n    }\\n    object[key].push(value);\\n  });\\n  if (stringify) return JSON.stringify(object);\\n  return object;\\n}\\nfunction logg(txt) {\\n  var k = \\\"\\\";\\n  if (document.querySelectorAll('.logg')) {\\n    k = '.logg';\\n  } else if (document.querySelectorAll('.mess')) {\\n    k = '.mess';\\n  }\\n  if (k != \\\"\\\") {\\n    var loggElems = document.querySelectorAll(k);\\n    for (var i = 0; i < loggElems.length; i++) {\\n      var loggElem = loggElems[i];\\n      loggElem.innerHTML = txt;\\n    }\\n  } else {\\n    console.log(txt);\\n  }\\n}\\n\\n///AJAX///\\nfunction myAjax(jsonData, callback, url = \\\"\\\", type = \\\"POST\\\", logResults = true) {\\n  var req = new XMLHttpRequest();\\n  req.onreadystatechange = function () {\\n    if (req.readyState == 4) {\\n      console.log('STATUS:' + req.status);\\n      if (req.status >= 200 && req.status < 300) {\\n        // callback(req.responseText);\\n        if (isJSON(req.responseText)) {\\n          var json = JSON.parse(req.responseText);\\n          callback(json);\\n        } else {\\n          callback(req.responseText);\\n        }\\n      } else if (req.status >= 300) {\\n        if (isJSON(req.responseText)) {\\n          var json = JSON.parse(req.responseText);\\n          if (isObject(json) && 'message' in json) if (logResults) logg(json.message);else console.log(json.message);\\n        } else {\\n          if (logResults) logg(req.responseText);else console.log(req.responseText);\\n        }\\n      } else {\\n        if (logResults) logg(req.responseText);else console.log(req.responseText);\\n      }\\n    } else {\\n      if (logResults) logg('Loading...' + req.readyState);\\n    }\\n  };\\n  req.open(type, url, true);\\n  req.setRequestHeader('Content-Type', 'application/json');\\n  req.setRequestHeader(\\\"Content-Type\\\", \\\"multipart/form-data\\\");\\n  if (type.toUpperCase() == \\\"POST\\\") {\\n    req.send(JSON.stringify(jsonData));\\n  } else {\\n    req.send();\\n  }\\n}\\nasync function getBase64(file) {\\n  // console.log(file);\\n  return new Promise((res, rej) => {\\n    let reader = new FileReader();\\n    reader.onload = () => {\\n      return res(reader.result);\\n    };\\n    reader.onerror = err => {\\n      rej(err);\\n    };\\n    reader.readAsDataURL(file);\\n  });\\n}\\nfunction ajax(data, url = \\\"\\\", type = \\\"POST\\\", success = function () {}, fail = function () {}) {\\n  var req = new XMLHttpRequest();\\n  req.onreadystatechange = function () {\\n    if (req.readyState == 4) {\\n      console.log('STATUS:' + req.status);\\n      if (req.status >= 200 && req.status < 300) {\\n        success(req.responseText);\\n      } else if (req.status >= 300) {\\n        fail(req.responseText);\\n      } else {\\n        console.log(req.responseText);\\n      }\\n    } else {}\\n  };\\n  req.open(type, url, true);\\n  // req.setRequestHeader('Content-Type', 'application/json');\\n  // req.setRequestHeader(\\\"Content-Type\\\", \\\"multipart/form-data\\\");\\n  if (type.toUpperCase() == \\\"POST\\\") {\\n    req.send(data);\\n  } else {\\n    req.send();\\n  }\\n}\\nfunction ajaxGET(url, callback, failback = function () {}) {\\n  ajax(\\\"\\\", url, \\\"GET\\\", callback, failback);\\n}\\nfunction ajaxPOST(data, url, callback, failback = function () {}) {\\n  ajax(data, url, \\\"POST\\\", callback, failback);\\n}\\nfunction getFileBlob(url, type = \\\"\\\", callback = (uurl, bblob, bbytes) => {}) {\\n  var oReq = new XMLHttpRequest();\\n  oReq.open(\\\"GET\\\", url, true);\\n  oReq.responseType = \\\"arraybuffer\\\";\\n  oReq.onload = function (oEvent) {\\n    var arrayBuffer = oReq.response;\\n\\n    // if you want to access the bytes:\\n    var byteArray = new Uint8Array(arrayBuffer);\\n    // ...\\n\\n    // If you want to use the image in your DOM:\\n    var _blob = new Blob([arrayBuffer], {\\n      type: type\\n    });\\n    // var _blob = new File([arrayBuffer], hash32(url), {type: type});\\n    var _url = URL.createObjectURL(_blob);\\n    callback(_url, _blob, byteArray);\\n    //callback(URL,FILEBLOB,FILEDATA);\\n  };\\n\\n  oReq.send();\\n}\\nfunction processAjaxData(contentElement, urlPath = \\\"\\\", response = null, state = {}, callback = function () {}) {\\n  var newState = jQuery.extend(true, {}, state);\\n  if (response) {\\n    newState.html = response.html;\\n    newState.pageTitle = response.pageTitle;\\n    if (contentElement) contentElement.innerHTML = response.html;\\n    document.title = response.pageTitle;\\n  } else {\\n    newState.html = '';\\n    newState.pageTitle = '';\\n  }\\n  window.history.pushState(newState, newState.pageTitle, urlPath);\\n  callback();\\n}\\nfunction setHistoryState(urlPath = \\\"\\\", response = null, state = {}, callback = function () {}) {\\n  var newState = jQuery.extend(true, {}, state);\\n  if (response) {\\n    newState.html = response.html;\\n    newState.pageTitle = response.pageTitle;\\n    document.title = response.pageTitle;\\n  } else {\\n    newState.html = '';\\n    newState.pageTitle = '';\\n  }\\n  window.history.replaceState(newState, newState.pageTitle, urlPath);\\n  callback();\\n}\\nfunction pushHistoryState(urlPath = \\\"\\\", response = null, state = {}, callback = function () {}) {\\n  var newState = jQuery.extend(true, {}, state);\\n  if (response) {\\n    newState.html = response.html;\\n    newState.pageTitle = response.pageTitle;\\n    document.title = response.pageTitle;\\n  } else {\\n    newState.html = '';\\n    newState.pageTitle = '';\\n  }\\n  window.history.pushState(newState, newState.pageTitle, urlPath);\\n  callback();\\n}\\nfunction objectToURLParams(obj) {\\n  var parts = [];\\n  for (var key in obj) {\\n    if (obj.hasOwnProperty(key)) {\\n      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));\\n    }\\n  }\\n  return \\\"?\\\" + parts.join('&');\\n}\\n\\n//ref: https://stackoverflow.com/questions/814613/how-to-read-get-data-from-a-url-using-javascript\\nfunction parseURLParams(url, typecast = false, autoParseObjects = false) {\\n  var queryStart = url.indexOf(\\\"?\\\") + 1,\\n    queryEnd = url.indexOf(\\\"#\\\") + 1 || url.length + 1,\\n    query = url.slice(queryStart, queryEnd - 1),\\n    pairs = query.replace(/\\\\+/g, \\\" \\\").split(\\\"&\\\"),\\n    params = {},\\n    i,\\n    n,\\n    v,\\n    nv,\\n    nx;\\n  if (query === url || query === \\\"\\\") return;\\n  for (i = 0; i < pairs.length; i++) {\\n    nv = pairs[i].split(\\\"=\\\", 2);\\n    n = decodeURIComponent(nv[0]);\\n    v = decodeURIComponent(nv[1]);\\n    nx = null;\\n    if (typecast) {\\n      if (autoParseObjects) {\\n        if (n.includes('[')) {\\n          //test for array\\n          if (n.includes('[]')) {\\n            n = n.replace('[]', '');\\n            if (!params.hasOwnProperty(n)) params[n] = [];\\n          }\\n          //test for object\\n          else if (n.includes(']')) {\\n            var nn = n.split('[', 2);\\n            n = nn[0];\\n            nx = nn[1].replace(']', '');\\n            if (!params.hasOwnProperty(n)) params[n] = {};\\n            params[n][nx] = null;\\n          }\\n        }\\n      }\\n      //test for number\\n      if (!isNaN(v)) v = Number(v);else {\\n        //test for boolean\\n        v = v === 'true' || (v === 'false' ? false : v);\\n        //test for nullable\\n        v = v === 'undefined' ? undefined : v === 'null' ? null : v;\\n      }\\n    }\\n    if (!params.hasOwnProperty(n)) {\\n      params[n] = v;\\n    } else {\\n      if (typeof params[n] !== 'object') {\\n        params[n] = [params[n]];\\n      } else if (params[n] instanceof Array) params[n].push(nv.length === 2 ? v : null);else if (nx != null) params[n][nx] = v;\\n    }\\n  }\\n  /*for(var param of Object.keys(params)){\\r\\n  \\tif(params[param] instanceof Array && params[param].length == 1)\\r\\n  \\t\\tparams[param] = params[param][0];\\r\\n  }*/\\n  return params;\\n}\\n\\n///COOKIES///\\n//reference: https://www.w3schools.com/js/js_cookies.asp\\nfunction checkCookie(cname) {\\n  let cookey = getCookie(cname);\\n  if (cookey != \\\"\\\") return true;\\n  return false;\\n}\\nfunction setCookie(cname, cvalue, exdays = 1) {\\n  let d = new Date();\\n  d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);\\n  let expires = \\\"expires=\\\" + d.toUTCString();\\n  document.cookie = cname + \\\"=\\\" + cvalue + \\\";\\\" + expires + \\\"; path=/\\\";\\n}\\nfunction deleteCookie(cname) {\\n  document.cookie = cname + \\\"=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\\\";\\n}\\nfunction getCookie(cname) {\\n  var name = cname + \\\"=\\\";\\n  var decodedCookie = decodeURIComponent(document.cookie);\\n  var ca = decodedCookie.split(';');\\n  for (var i = 0; i < ca.length; i++) {\\n    var c = ca[i];\\n    while (c.charAt(0) == ' ') {\\n      c = c.substring(1);\\n    }\\n    if (c.indexOf(name) == 0) {\\n      return c.substring(name.length, c.length);\\n    }\\n  }\\n  return \\\"\\\";\\n}\\n///VERIFY DATA TYPE///\\nfunction isInt(val) {\\n  return isNumber(val) && Math.trunc(val) === val;\\n}\\nfunction isNumber(val) {\\n  return !isNaN(Number(val));\\n}\\nfunction isArray(arr) {\\n  return typeof arr === 'object' && arr instanceof Array;\\n}\\nfunction isString(str) {\\n  return typeof str === 'string';\\n}\\nfunction isFunction(func) {\\n  return typeof func === 'function' || func instanceof Function;\\n}\\nfunction isObject(object) {\\n  return object != null && typeof object === 'object';\\n}\\nfunction isInRange(num, min, max, inclusive = true) {\\n  if (inclusive) return num >= min && num <= max;else return num > min && num < max;\\n}\\nfunction isJSON(str) {\\n  if (!isString(str)) {\\n    str = JSON.stringify(str);\\n  }\\n  let obj = null;\\n  try {\\n    obj = JSON.parse(str);\\n  } catch (e) {\\n    return false;\\n  }\\n  if (isObject(obj)) return true;\\n  return false;\\n}\\nfunction link_is_external(link_element, _location = window.location) {\\n  return link_element.host !== _location.host;\\n}\\nfunction isExternalURLFast(url) {\\n  var match = url.match(/^([^:\\\\/?#]+:)?(?:\\\\/\\\\/([^\\\\/?#]*))?([^?#]+)?(\\\\?[^#]*)?(#.*)?/);\\n  if (typeof match[1] === \\\"string\\\" && match[1].length > 0 && match[1].toLowerCase() !== location.protocol) return true;\\n  if (typeof match[2] === \\\"string\\\" && match[2].length > 0 && match[2].replace(new RegExp(\\\":(\\\" + {\\n    \\\"http:\\\": 80,\\n    \\\"https:\\\": 443\\n  }[location.protocol] + \\\")?$\\\"), \\\"\\\") !== location.host) return true;\\n  return false;\\n}\\nfunction isExternalURL(url) {\\n  try {\\n    if (typeof URL === 'undefined') {}\\n  } catch (e) {\\n    console.debug(e);\\n  }\\n  var res = false;\\n  try {\\n    res = new URL(url).origin !== location.origin;\\n  } catch (e) {\\n    return false;\\n  }\\n  return res;\\n}\\nfunction JSONobjectsAreEqual(objA, objB) {\\n  var jsonA = JSON.stringify(objA);\\n  var jsonB = JSON.stringify(objB);\\n  if (jsonA === jsonB) return true;\\n  return false;\\n}\\n\\n///GENERATING RANDOM VALUE///\\n\\nfunction randomId(_prefix = '', _suffix = '') {\\n  return _prefix + Math.random().toString(36).substr(2, 9) + _suffix;\\n}\\nfunction randomID(_prefix = '', _suffix = '', _length = 9) {\\n  return _prefix + randomString(9) + _suffix;\\n}\\nfunction hexadecimalID(_len = 16, _pow = 4) {\\n  return Math.floor((1 + Math.random()) * Math.pow(_len, _pow)).toString(16).substring(1);\\n}\\nfunction randomString(length, chars) {\\n  if (!chars) chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';else chars = String(chars);\\n  var result = '';\\n  for (var i = length; i > 0; --i) result += chars[Math.floor(Math.random() * chars.length)];\\n  return result;\\n}\\nfunction randomCharFrom(str) {\\n  return randomString(1, str);\\n}\\nfunction rndInt(min, max) {\\n  return Math.floor(Math.random() * (max - min + 1)) + min;\\n}\\nfunction randomItemFrom(arr) {\\n  return arr[rndInt(0, arr.length - 1)];\\n}\\nfunction safeStringify(obj) {\\n  let cache = [];\\n  let s = JSON.stringify(obj, (key, value) => {\\n    if (isObject(value)) {\\n      // Duplicate reference found, discard key\\n      if (cache.includes(value)) return;\\n      // Store value in our collection\\n      cache.push(value);\\n    }\\n    return value;\\n  });\\n  cache = null; // Enable garbage collection\\n\\n  return s;\\n}\\n\\n///HASHING///\\nfunction hash32(str) {\\n  var hash = 0,\\n    i,\\n    chr;\\n  str = String(str);\\n  if (str.length === 0) return hash;\\n  for (i = 0; i < str.length; i++) {\\n    chr = str.charCodeAt(i);\\n    hash = (hash << 5) - hash + chr;\\n    hash |= 0; // Convert to 32bit integer\\n  }\\n\\n  return String(hash);\\n}\\nfunction hash64(str) {\\n  var h1 = hash32(str); // returns 32 bit (as 8 byte hex string)\\n  return h1 + hash32(h1 + str); // 64 bit (as 16 byte hex string)\\n}\\n\\nfunction hash128(str) {\\n  var h1 = hash64(str); // returns 64 bit (as 16 byte hex string)\\n  return h1 + hash64(h1 + str); // 128 bit (as 32 byte hex string)\\n}\\n\\n//OTHER//\\nfunction stringTrimToLength(_str, _len) {\\n  if (_len == null) _len = String(_str).length;\\n  _str = String(_str);\\n  return _str.substring(0, _len);\\n}\\nfunction jsonFix(str) {\\n  str = String(str);\\n  // let regex = /\\\\,(?=\\\\s*?[\\\\}\\\\]])/g;\\n  let regex = /\\\\,(?!\\\\s*?[\\\\{\\\\[\\\\\\\"\\\\'\\\\w])/g;\\n  var newStr = str.replace(regex, '');\\n  return newStr;\\n}\\nfunction deg2rad(deg) {\\n  var res = deg * Math.PI / 180;\\n  return res;\\n}\\nfunction rad2deg(rad) {\\n  var res = rad * 180 / Math.PI;\\n  return res;\\n}\\nfunction stepify(value, step) {\\n  if (step == 0) return value;\\n  if (step == Infinity) return 1;\\n  return Math.round((value + Number.EPSILON) / step) * step;\\n}\\nfunction splitStringByLength(str, len) {\\n  var parts = [];\\n  for (var i = 0; i < str.length; i += len) {\\n    parts.push(str.substring(i, i + len));\\n  }\\n  return parts;\\n}\\nfunction sanitizeString(str) {\\n  str = str.replace(/[^a-z0-9áéíóúñü \\\\.,_-]/gim, \\\"\\\");\\n  return str.trim();\\n}\\nfunction validateEmail(email) {\\n  return String(email).toLowerCase().match(/^(([^<>()[\\\\]\\\\\\\\.,;:\\\\s@\\\"]+(\\\\.[^<>()[\\\\]\\\\\\\\.,;:\\\\s@\\\"]+)*)|(\\\".+\\\"))@((\\\\[[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\])|(([a-zA-Z\\\\-0-9]+\\\\.)+[a-zA-Z]{2,}))$/);\\n}\\n//https://stackoverflow.com/questions/7744912/making-a-javascript-string-sql-friendly\\nfunction mysql_real_escape_string(str) {\\n  return str.replace(/[\\\\0\\\\x08\\\\x09\\\\x1a\\\\n\\\\r\\\"'\\\\\\\\\\\\%]/g, function (char) {\\n    switch (char) {\\n      case \\\"\\\\0\\\":\\n        return \\\"\\\\\\\\0\\\";\\n      case \\\"\\\\x08\\\":\\n        return \\\"\\\\\\\\b\\\";\\n      case \\\"\\\\x09\\\":\\n        return \\\"\\\\\\\\t\\\";\\n      case \\\"\\\\x1a\\\":\\n        return \\\"\\\\\\\\z\\\";\\n      case \\\"\\\\n\\\":\\n        return \\\"\\\\\\\\n\\\";\\n      case \\\"\\\\r\\\":\\n        return \\\"\\\\\\\\r\\\";\\n      case \\\"\\\\\\\"\\\":\\n      case \\\"'\\\":\\n      case \\\"\\\\\\\\\\\":\\n      case \\\"%\\\":\\n        return \\\"\\\\\\\\\\\" + char;\\n      // prepends a backslash to backslash, percent, and double/single quotes\\n      default:\\n        return char;\\n    }\\n  });\\n}\\n\\n///OBJECTS\\n\\nfunction areSimilar(objA, objB) {\\n  if (objA == objB) return true;\\n  if (isObject(objA) && isObject(objB)) {\\n    objA = JSON.parse(JSON.stringify(objA));\\n    objB = JSON.parse(JSON.stringify(objB));\\n    for (let k of Object.keys(objA)) {\\n      if (!(k in objB)) return false;\\n      if (!areSimilar(objA[k], obj[k])) return false;\\n    }\\n    return true;\\n  } else {\\n    if (typeof objA === typeof objB) {\\n      return objA === objB;\\n    }\\n  }\\n  return false;\\n}\\n\\n///ARRAYS\\n\\nfunction hardPush(arr, item, compareProps) {\\n  if (!arr || !(arr instanceof Array)) return false;\\n  if (!item) return false;\\n  if (!arr.length) {\\n    arr.push(item);\\n    return true;\\n  }\\n  if (arr.indexOf(item) >= 0) return false;\\n  for (var i = 0; i < arr.length; i++) {\\n    var arrItem = arr[i];\\n    if (isObject(arrItem) && isObject(item)) {\\n      if (compareProps && isArray(compareProps)) {\\n        for (let prop of compareProps) {\\n          if (prop in arrItem && areSimilar(arrItem[prop], item[prop])) {\\n            return false;\\n          }\\n        }\\n      }\\n    } else if (arrItem === item) {\\n      return false;\\n    }\\n  }\\n  arr.push(item);\\n  return true;\\n}\\nfunction shallowEqual(object1, object2) {\\n  let keys1 = Object.keys(object1);\\n  let keys2 = Object.keys(object2);\\n  if (keys1.length !== keys2.length) {\\n    return false;\\n  }\\n  for (let key of keys1) {\\n    if (object1[key] !== object2[key]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\nfunction deepEqual(object1, object2) {\\n  let keys1 = Object.keys(object1);\\n  let keys2 = Object.keys(object2);\\n  if (keys1.length !== keys2.length) {\\n    return false;\\n  }\\n  for (let key of keys1) {\\n    let val1 = object1[key];\\n    let val2 = object2[key];\\n    let areObjects = isObject(val1) && isObject(val2);\\n    if (areObjects && !deepEqual(val1, val2) || !areObjects && val1 !== val2) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\nfunction findItemIndex(arr, item) {\\n  if (!arr || !(arr instanceof Array)) return null;\\n  if (!item) return null;\\n  for (let i = 0; i < arr.length; i++) {\\n    let arrItem = arr[i];\\n    if (isObject(arrItem) && isObject(item)) if (shallowEqual(arrItem, item)) return i;else if (arrItem === item) return i;\\n  }\\n  return false;\\n}\\nfunction findItem(arr, item) {\\n  var res = findItemIndex(arr, item);\\n  if (res === false) return false;\\n  return true;\\n}\\nfunction arrayRemove(arr, item) {\\n  var res = arr.indexOf(item);\\n  if (res < 0) return false;\\n  let x = arr.splice(res, 1);\\n  return x.length > 0;\\n}\\nfunction findItemObject(arr, item, compareProperties = null) {\\n  var res = findItemObjectIndex(arr, item, compareProperties);\\n  if (res === false) return false;\\n  return true;\\n}\\nfunction findItemObjectIndex(arr, item, compareProperties = null) {\\n  if (!arr || !(arr instanceof Array)) return false;\\n  if (!item) return false;\\n  if (arr.length == 0) {\\n    return false;\\n  }\\n  for (var i = 0; i < arr.length; i++) {\\n    let arrItem = arr[i];\\n    if (arrItem instanceof Object && item instanceof Object) {\\n      if (compareProperties && compareProperties instanceof Array) {\\n        for (let pproperty of compareProperties) {\\n          if (arrItem.hasOwnProperty(pproperty) && arrItem[pproperty] === item[pproperty]) return i;\\n        }\\n      } else if (shallowEqual(arrItem, item)) return i;\\n    } else if (arrItem === item) return i;\\n  }\\n  return false;\\n}\\nfunction getObjectFromArray(arr, properties) {\\n  if (!arr || !(arr instanceof Array)) return false;\\n  if (!properties) return false;\\n  if (arr.length == 0) {\\n    return false;\\n  }\\n  var item = properties;\\n  var compareProperties = Object.keys(item);\\n  for (var i = 0; i < arr.length; i++) {\\n    var arrItem = arr[i];\\n    if (arrItem instanceof Object && item instanceof Object) {\\n      if (compareProperties && compareProperties instanceof Array) {\\n        for (let prop of compareProperties) {\\n          if (arrItem.hasOwnProperty(prop) && arrItem[prop] === item[prop]) return arrItem;\\n        }\\n      } else if (shallowEqual(arrItem, item)) return arrItem;\\n    } else if (arrItem === item) return arrItem;\\n  }\\n  return false;\\n}\\nfunction getClosestPathInCircle(arr, _from, _to, bias = 0) {\\n  if (!(arr instanceof Array)) {\\n    return [];\\n  }\\n  if (_from < 0 || _from >= arr.length) {\\n    return [];\\n  }\\n  if (_to < 0 || _to >= arr.length) {\\n    return [];\\n  }\\n  let iL = iR = _from;\\n  let arrL = [],\\n    arrR = [];\\n  let arrX;\\n  while (arrL.length < arr.length) {\\n    let _i = mod(iL, arr.length);\\n    arrL.push(arr[_i]);\\n    if (Math.abs(_i) == _to) break;\\n    iL--;\\n  }\\n  while (arrR.length < arr.length) {\\n    let _i = mod(iR, arr.length);\\n    arrR.push(arr[_i]);\\n    if (Math.abs(_i) == _to) break;\\n    iR++;\\n  }\\n  if (Math.abs(arrL.length) < Math.abs(arrR.length)) {\\n    arrX = arrL;\\n  } else if (Math.abs(arrL.length) > Math.abs(arrR.length)) {\\n    arrX = arrR;\\n  } else {\\n    if (bias > 0) arrX = arrR;else arrX = arrL;\\n  }\\n  return arrX;\\n}\\nfunction roundTo(num, step) {\\n  if (step == 0) return num;\\n  if (isInfinity(step)) return Infinity;\\n  let invStep = Math.pow(step, -1);\\n  let invMiniStep = Math.pow(step / 10, -1);\\n  let initNum = Math.round(num * invMiniStep) / invMiniStep;\\n  let init = Math.round(initNum * invStep) / invStep;\\n  // let res = init;\\n  let res = Math.round((init + Number.EPSILON) * invStep) / invStep;\\n  return res;\\n}\\n\\n//# sourceURL=webpack://MY/./lib/cjs/src/myHelperFunctions.js?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_31724__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_31724__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can't be inlined because the eval devtool is used.\n/******/ \tvar __webpack_exports__ = __nested_webpack_require_31724__(\"./lib/cjs/index.js\");\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n\n//# sourceURL=webpack://TargetObservers/./node_modules/@catsums/my/lib/umd/index.dev.js?");

/***/ }),

/***/ "./node_modules/@catsums/vector2/lib/umd/index.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/@catsums/vector2/lib/umd/index.dev.js ***!
  \************************************************************/
/***/ (function(module) {

eval("/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./node_modules/@catsums/my/lib/umd/index.dev.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/@catsums/my/lib/umd/index.dev.js ***!\n  \\*******************************************************/\n/***/ (function(module) {\n\neval(\"/*\\n * ATTENTION: The \\\"eval\\\" devtool has been used (maybe by default in mode: \\\"development\\\").\\n * This devtool is neither made for production nor for readable output files.\\n * It uses \\\"eval()\\\" calls to create a separate source file in the browser devtools.\\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\\n * or disable the default devtool with \\\"devtool: false\\\".\\n * If you are looking for production-ready output files, see mode: \\\"production\\\" (https://webpack.js.org/configuration/mode/).\\n */\\n(function webpackUniversalModuleDefinition(root, factory) {\\n\\tif(true)\\n\\t\\tmodule.exports = factory();\\n\\telse {}\\n})(this, () => {\\nreturn /******/ (() => { // webpackBootstrap\\n/******/ \\t\\\"use strict\\\";\\n/******/ \\tvar __webpack_modules__ = ({\\n\\n/***/ \\\"./lib/cjs/index.js\\\":\\n/*!**************************!*\\\\\\n  !*** ./lib/cjs/index.js ***!\\n  \\\\**************************/\\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\\n\\neval(\\\"\\\\n\\\\nmodule.exports = __webpack_require__(/*! ./src */ \\\\\\\"./lib/cjs/src/index.js\\\\\\\");\\\\n\\\\n//# sourceURL=webpack://MY/./lib/cjs/index.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./lib/cjs/src/index.js\\\":\\n/*!******************************!*\\\\\\n  !*** ./lib/cjs/src/index.js ***!\\n  \\\\******************************/\\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\\n\\neval(\\\"\\\\n\\\\nvar MY = _interopRequireWildcard(__webpack_require__(/*! ./myHelperFunctions.js */ \\\\\\\"./lib/cjs/src/myHelperFunctions.js\\\\\\\"));\\\\nfunction _getRequireWildcardCache(nodeInterop) {\\\\n  if (typeof WeakMap !== \\\\\\\"function\\\\\\\") return null;\\\\n  var cacheBabelInterop = new WeakMap();\\\\n  var cacheNodeInterop = new WeakMap();\\\\n  return (_getRequireWildcardCache = function (nodeInterop) {\\\\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\\\\n  })(nodeInterop);\\\\n}\\\\nfunction _interopRequireWildcard(obj, nodeInterop) {\\\\n  if (!nodeInterop && obj && obj.__esModule) {\\\\n    return obj;\\\\n  }\\\\n  if (obj === null || typeof obj !== \\\\\\\"object\\\\\\\" && typeof obj !== \\\\\\\"function\\\\\\\") {\\\\n    return {\\\\n      default: obj\\\\n    };\\\\n  }\\\\n  var cache = _getRequireWildcardCache(nodeInterop);\\\\n  if (cache && cache.has(obj)) {\\\\n    return cache.get(obj);\\\\n  }\\\\n  var newObj = {};\\\\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\\\\n  for (var key in obj) {\\\\n    if (key !== \\\\\\\"default\\\\\\\" && Object.prototype.hasOwnProperty.call(obj, key)) {\\\\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\\\\n      if (desc && (desc.get || desc.set)) {\\\\n        Object.defineProperty(newObj, key, desc);\\\\n      } else {\\\\n        newObj[key] = obj[key];\\\\n      }\\\\n    }\\\\n  }\\\\n  newObj.default = obj;\\\\n  if (cache) {\\\\n    cache.set(obj, newObj);\\\\n  }\\\\n  return newObj;\\\\n}\\\\nmodule.exports = MY;\\\\n\\\\n//# sourceURL=webpack://MY/./lib/cjs/src/index.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./lib/cjs/src/myHelperFunctions.js\\\":\\n/*!******************************************!*\\\\\\n  !*** ./lib/cjs/src/myHelperFunctions.js ***!\\n  \\\\******************************************/\\n/***/ ((__unused_webpack_module, exports) => {\\n\\neval(\\\"\\\\n\\\\nObject.defineProperty(exports, \\\\\\\"__esModule\\\\\\\", ({\\\\n  value: true\\\\n}));\\\\nexports.JSONobjectsAreEqual = JSONobjectsAreEqual;\\\\nexports.ajax = ajax;\\\\nexports.ajaxGET = ajaxGET;\\\\nexports.ajaxPOST = ajaxPOST;\\\\nexports.areSimilar = areSimilar;\\\\nexports.arrayRemove = arrayRemove;\\\\nexports.checkBootstrapMedia = checkBootstrapMedia;\\\\nexports.checkCookie = checkCookie;\\\\nexports.clog = clog;\\\\nexports.cout = cout;\\\\nexports.deepEqual = deepEqual;\\\\nexports.defectAllFormSubmits = defectAllFormSubmits;\\\\nexports.deg2rad = deg2rad;\\\\nexports.deleteCookie = deleteCookie;\\\\nexports.docReady = docReady;\\\\nexports.findItem = findItem;\\\\nexports.findItemIndex = findItemIndex;\\\\nexports.findItemObject = findItemObject;\\\\nexports.findItemObjectIndex = findItemObjectIndex;\\\\nexports.footstrapMediaQueries = void 0;\\\\nexports.forMediaQuery = forMediaQuery;\\\\nexports.formDataToJSON = formDataToJSON;\\\\nexports.getAverageFrom = getAverageFrom;\\\\nexports.getBase64 = getBase64;\\\\nexports.getCSSValueInPixels = getCSSValueInPixels;\\\\nexports.getClosestPathInCircle = getClosestPathInCircle;\\\\nexports.getCookie = getCookie;\\\\nexports.getFileBlob = getFileBlob;\\\\nexports.getFormData = getFormData;\\\\nexports.getObjectFromArray = getObjectFromArray;\\\\nexports.hardPush = hardPush;\\\\nexports.hash128 = hash128;\\\\nexports.hash32 = hash32;\\\\nexports.hash64 = hash64;\\\\nexports.hexadecimalID = hexadecimalID;\\\\nexports.isArray = isArray;\\\\nexports.isExternalURL = isExternalURL;\\\\nexports.isExternalURLFast = isExternalURLFast;\\\\nexports.isFunction = isFunction;\\\\nexports.isInRange = isInRange;\\\\nexports.isInfinity = isInfinity;\\\\nexports.isInt = isInt;\\\\nexports.isJSON = isJSON;\\\\nexports.isNumber = isNumber;\\\\nexports.isObject = isObject;\\\\nexports.isString = isString;\\\\nexports.jsonFix = jsonFix;\\\\nexports.link_is_external = link_is_external;\\\\nexports.loadHTMLtoObject = loadHTMLtoObject;\\\\nexports.logg = logg;\\\\nexports.mod = mod;\\\\nexports.myAjax = myAjax;\\\\nexports.mysql_real_escape_string = mysql_real_escape_string;\\\\nexports.objectToURLParams = objectToURLParams;\\\\nexports.parseURLParams = parseURLParams;\\\\nexports.processAjaxData = processAjaxData;\\\\nexports.pushHistoryState = pushHistoryState;\\\\nexports.rad2deg = rad2deg;\\\\nexports.randomCharFrom = randomCharFrom;\\\\nexports.randomID = randomID;\\\\nexports.randomId = randomId;\\\\nexports.randomItemFrom = randomItemFrom;\\\\nexports.randomString = randomString;\\\\nexports.rndInt = rndInt;\\\\nexports.roundTo = roundTo;\\\\nexports.safeDivide = safeDivide;\\\\nexports.safeStringify = safeStringify;\\\\nexports.sanitizeString = sanitizeString;\\\\nexports.setCookie = setCookie;\\\\nexports.setHistoryState = setHistoryState;\\\\nexports.shallowEqual = shallowEqual;\\\\nexports.splitStringByLength = splitStringByLength;\\\\nexports.stepify = stepify;\\\\nexports.stringTrimToLength = stringTrimToLength;\\\\nexports.submitForm = submitForm;\\\\nexports.validateEmail = validateEmail;\\\\n/*myHelperModule.js*/\\\\n///FOR WEB API FRONT-END MODULES\\\\n\\\\n///CONSOLE///\\\\nfunction cout(...vars) {\\\\n  console.log(...vars);\\\\n}\\\\nfunction clog(...x) {\\\\n  console.log(...x);\\\\n}\\\\n\\\\n///OBJECT MODIFICATION///\\\\ntry {\\\\n  if (typeof Storage !== 'undefined') {\\\\n    Storage.prototype.setObject = function (key, value) {\\\\n      this.setItem(key, JSON.stringify(value));\\\\n    };\\\\n    Storage.prototype.getObject = function (key) {\\\\n      var value = this.getItem(key);\\\\n      return value && JSON.parse(value);\\\\n    };\\\\n  }\\\\n} catch (err) {\\\\n  console.debug(err);\\\\n}\\\\nArray.prototype.midCeil = function () {\\\\n  return this[Math.ceil(this.length / 2)];\\\\n};\\\\nArray.prototype.midFloor = function () {\\\\n  return this[Math.floor(this.length / 2)];\\\\n};\\\\nArray.prototype.midRound = function () {\\\\n  return this[Math.round(this.length / 2)];\\\\n};\\\\nArray.prototype.last = function () {\\\\n  return this[this.length - 1];\\\\n};\\\\nArray.prototype.first = function () {\\\\n  return this[0];\\\\n};\\\\nArray.prototype.removeAt = function (index) {\\\\n  return this.splice(index, 1);\\\\n};\\\\nArray.prototype.removeItem = function (item) {\\\\n  let ind = this.indexOf(item);\\\\n  return this.splice(ind, 1) > 0;\\\\n};\\\\nBigInt.prototype.toJSON = function () {\\\\n  return this.toString();\\\\n};\\\\n\\\\n///MOD\\\\n\\\\n///note that % operator in js is the Remainder operator and not Modulus\\\\n///:. (-1 % 5) gives -1 and not 4 as expected with modulus\\\\n\\\\nNumber.prototype.mod = function (n) {\\\\n  return (this % n + n) % n;\\\\n};\\\\nfunction mod(n, m) {\\\\n  return (n % m + m) % m;\\\\n}\\\\n\\\\n///Safe Division\\\\nfunction isInfinity(x) {\\\\n  return x === -Infinity || x === Infinity;\\\\n}\\\\nfunction safeDivide(a, b, useNaN = false) {\\\\n  let INF = Infinity;\\\\n  let res;\\\\n  if (a == 0 && b == 0) {\\\\n    if (useNaN) res = NaN;else res = 0;\\\\n  } else if (a == 0 && isInfinity(b)) {\\\\n    res = 0 * 1;\\\\n  } else if (isInfinity(a) && b == 0) {\\\\n    res = a * 1;\\\\n  } else if (isInfinity(a) && isInfinity(b)) {\\\\n    if (useNaN) res = NaN;else if (a == b) res = 1;else res = -1;\\\\n  } else if (b == 0) {\\\\n    if (useNaN) res = NaN;\\\\n    res = INF * a;\\\\n  } else if (isInfinity(b)) {\\\\n    if (useNaN) res = NaN;\\\\n    res = 0 * a;\\\\n  } else {\\\\n    res = a / b;\\\\n  }\\\\n  return res;\\\\n}\\\\nfunction getAverageFrom(arr) {\\\\n  if (!isArray(arr)) return null;\\\\n  if (!arr.length) return 0;\\\\n  let sum = arr.reduce((_sum, x) => {\\\\n    return _sum + x;\\\\n  }, 0);\\\\n  return sum / arr.length;\\\\n}\\\\n\\\\n///CSS///\\\\n\\\\nfunction getCSSValueInPixels(str) {\\\\n  let num = 0;\\\\n  let val = parseFloat(str);\\\\n  let unit = str.replace(`${val}`, '').trim();\\\\n  switch (unit) {\\\\n    case 'in':\\\\n      num = val * 96;\\\\n      break;\\\\n    case 'cm':\\\\n      num = val / 2.54 * 96;\\\\n      break;\\\\n    case 'mm':\\\\n      num = val / 100 / 2.54 * 96;\\\\n      break;\\\\n    case 'pt':\\\\n      num = val * 72 * 96;\\\\n      break;\\\\n    case 'pc':\\\\n      num = val * 12 * 72 * 96;\\\\n      break;\\\\n    default:\\\\n      //treat as px\\\\n      num = val;\\\\n      break;\\\\n  }\\\\n  return num;\\\\n}\\\\n\\\\n///OBJECT AND HTML///\\\\nfunction loadHTMLtoObject(query, url) {\\\\n  document.querySelector(query).setAttribute('data', url);\\\\n}\\\\nfunction docReady(fn) {\\\\n  // see if DOM is already available\\\\n  if (document.readyState === \\\\\\\"complete\\\\\\\" || document.readyState === \\\\\\\"interactive\\\\\\\") {\\\\n    // call on next available tick\\\\n    setTimeout(fn, 1);\\\\n  } else {\\\\n    document.addEventListener(\\\\\\\"DOMContentLoaded\\\\\\\", fn);\\\\n  }\\\\n}\\\\n\\\\n///MEDIA QUERIES///\\\\nlet footstrapMediaQueries = {\\\\n  xs: '0px',\\\\n  sm: '576px',\\\\n  md: '768px',\\\\n  lg: '992px',\\\\n  xl: '1200px',\\\\n  xxl: '1400px'\\\\n};\\\\nexports.footstrapMediaQueries = footstrapMediaQueries;\\\\nfunction forMediaQuery(mediaQuery, matchFunc, unmatchFunc) {\\\\n  let match = window.matchMedia(mediaQuery);\\\\n  if (match.matches) {\\\\n    matchFunc();\\\\n  } else {\\\\n    unmatchFunc();\\\\n  }\\\\n}\\\\nfunction checkBootstrapMedia() {\\\\n  // let qKeys = Object.keys(footstrapMediaQueries);\\\\n  let qVals = Object.values(footstrapMediaQueries);\\\\n  for (var c = qVals.length - 1; c >= 0; c--) {\\\\n    let qVal = qVals[c];\\\\n    let match = window.matchMedia(`(max-width: ${qVal})`);\\\\n    if (match.matches) return qKey;\\\\n  }\\\\n  return 'xs';\\\\n}\\\\n\\\\n///FORMS///\\\\nfunction getFormData(query) {\\\\n  let formElement;\\\\n  if (typeof query === 'string') formElement = document.querySelector(query);else if (query instanceof HTMLFormElement) formElement = query;else return null;\\\\n  let formData = new FormData(formElement);\\\\n  return formData;\\\\n}\\\\nfunction submitForm(query, callback, url) {\\\\n  let formElement = document.querySelector(query);\\\\n  let formData = new FormData(formElement);\\\\n  let methodType = formElement.getAttribute('method');\\\\n  ajax(formData, callback, url, methodType);\\\\n}\\\\nvar handleForm = e => {\\\\n  e.preventDefault();\\\\n  console.debug('Submit has been defected. Please use JS to override form submit');\\\\n};\\\\nfunction defectAllFormSubmits() {\\\\n  let allForms = document.getElementsByTagName('form');\\\\n  for (var form of allForms) {\\\\n    form.submit = () => {};\\\\n    form.addEventListener('submit', handleForm);\\\\n  }\\\\n}\\\\nfunction formDataToJSON(formData, stringify = false) {\\\\n  let object = {};\\\\n  formData.forEach((value, key) => {\\\\n    // Reflect.has in favor of: object.hasOwnProperty(key)\\\\n    if (!Reflect.has(object, key)) {\\\\n      object[key] = value;\\\\n      return;\\\\n    }\\\\n    if (!Array.isArray(object[key])) {\\\\n      object[key] = [object[key]];\\\\n    }\\\\n    object[key].push(value);\\\\n  });\\\\n  if (stringify) return JSON.stringify(object);\\\\n  return object;\\\\n}\\\\nfunction logg(txt) {\\\\n  var k = \\\\\\\"\\\\\\\";\\\\n  if (document.querySelectorAll('.logg')) {\\\\n    k = '.logg';\\\\n  } else if (document.querySelectorAll('.mess')) {\\\\n    k = '.mess';\\\\n  }\\\\n  if (k != \\\\\\\"\\\\\\\") {\\\\n    var loggElems = document.querySelectorAll(k);\\\\n    for (var i = 0; i < loggElems.length; i++) {\\\\n      var loggElem = loggElems[i];\\\\n      loggElem.innerHTML = txt;\\\\n    }\\\\n  } else {\\\\n    console.log(txt);\\\\n  }\\\\n}\\\\n\\\\n///AJAX///\\\\nfunction myAjax(jsonData, callback, url = \\\\\\\"\\\\\\\", type = \\\\\\\"POST\\\\\\\", logResults = true) {\\\\n  var req = new XMLHttpRequest();\\\\n  req.onreadystatechange = function () {\\\\n    if (req.readyState == 4) {\\\\n      console.log('STATUS:' + req.status);\\\\n      if (req.status >= 200 && req.status < 300) {\\\\n        // callback(req.responseText);\\\\n        if (isJSON(req.responseText)) {\\\\n          var json = JSON.parse(req.responseText);\\\\n          callback(json);\\\\n        } else {\\\\n          callback(req.responseText);\\\\n        }\\\\n      } else if (req.status >= 300) {\\\\n        if (isJSON(req.responseText)) {\\\\n          var json = JSON.parse(req.responseText);\\\\n          if (isObject(json) && 'message' in json) if (logResults) logg(json.message);else console.log(json.message);\\\\n        } else {\\\\n          if (logResults) logg(req.responseText);else console.log(req.responseText);\\\\n        }\\\\n      } else {\\\\n        if (logResults) logg(req.responseText);else console.log(req.responseText);\\\\n      }\\\\n    } else {\\\\n      if (logResults) logg('Loading...' + req.readyState);\\\\n    }\\\\n  };\\\\n  req.open(type, url, true);\\\\n  req.setRequestHeader('Content-Type', 'application/json');\\\\n  req.setRequestHeader(\\\\\\\"Content-Type\\\\\\\", \\\\\\\"multipart/form-data\\\\\\\");\\\\n  if (type.toUpperCase() == \\\\\\\"POST\\\\\\\") {\\\\n    req.send(JSON.stringify(jsonData));\\\\n  } else {\\\\n    req.send();\\\\n  }\\\\n}\\\\nasync function getBase64(file) {\\\\n  // console.log(file);\\\\n  return new Promise((res, rej) => {\\\\n    let reader = new FileReader();\\\\n    reader.onload = () => {\\\\n      return res(reader.result);\\\\n    };\\\\n    reader.onerror = err => {\\\\n      rej(err);\\\\n    };\\\\n    reader.readAsDataURL(file);\\\\n  });\\\\n}\\\\nfunction ajax(data, url = \\\\\\\"\\\\\\\", type = \\\\\\\"POST\\\\\\\", success = function () {}, fail = function () {}) {\\\\n  var req = new XMLHttpRequest();\\\\n  req.onreadystatechange = function () {\\\\n    if (req.readyState == 4) {\\\\n      console.log('STATUS:' + req.status);\\\\n      if (req.status >= 200 && req.status < 300) {\\\\n        success(req.responseText);\\\\n      } else if (req.status >= 300) {\\\\n        fail(req.responseText);\\\\n      } else {\\\\n        console.log(req.responseText);\\\\n      }\\\\n    } else {}\\\\n  };\\\\n  req.open(type, url, true);\\\\n  // req.setRequestHeader('Content-Type', 'application/json');\\\\n  // req.setRequestHeader(\\\\\\\"Content-Type\\\\\\\", \\\\\\\"multipart/form-data\\\\\\\");\\\\n  if (type.toUpperCase() == \\\\\\\"POST\\\\\\\") {\\\\n    req.send(data);\\\\n  } else {\\\\n    req.send();\\\\n  }\\\\n}\\\\nfunction ajaxGET(url, callback, failback = function () {}) {\\\\n  ajax(\\\\\\\"\\\\\\\", url, \\\\\\\"GET\\\\\\\", callback, failback);\\\\n}\\\\nfunction ajaxPOST(data, url, callback, failback = function () {}) {\\\\n  ajax(data, url, \\\\\\\"POST\\\\\\\", callback, failback);\\\\n}\\\\nfunction getFileBlob(url, type = \\\\\\\"\\\\\\\", callback = (uurl, bblob, bbytes) => {}) {\\\\n  var oReq = new XMLHttpRequest();\\\\n  oReq.open(\\\\\\\"GET\\\\\\\", url, true);\\\\n  oReq.responseType = \\\\\\\"arraybuffer\\\\\\\";\\\\n  oReq.onload = function (oEvent) {\\\\n    var arrayBuffer = oReq.response;\\\\n\\\\n    // if you want to access the bytes:\\\\n    var byteArray = new Uint8Array(arrayBuffer);\\\\n    // ...\\\\n\\\\n    // If you want to use the image in your DOM:\\\\n    var _blob = new Blob([arrayBuffer], {\\\\n      type: type\\\\n    });\\\\n    // var _blob = new File([arrayBuffer], hash32(url), {type: type});\\\\n    var _url = URL.createObjectURL(_blob);\\\\n    callback(_url, _blob, byteArray);\\\\n    //callback(URL,FILEBLOB,FILEDATA);\\\\n  };\\\\n\\\\n  oReq.send();\\\\n}\\\\nfunction processAjaxData(contentElement, urlPath = \\\\\\\"\\\\\\\", response = null, state = {}, callback = function () {}) {\\\\n  var newState = jQuery.extend(true, {}, state);\\\\n  if (response) {\\\\n    newState.html = response.html;\\\\n    newState.pageTitle = response.pageTitle;\\\\n    if (contentElement) contentElement.innerHTML = response.html;\\\\n    document.title = response.pageTitle;\\\\n  } else {\\\\n    newState.html = '';\\\\n    newState.pageTitle = '';\\\\n  }\\\\n  window.history.pushState(newState, newState.pageTitle, urlPath);\\\\n  callback();\\\\n}\\\\nfunction setHistoryState(urlPath = \\\\\\\"\\\\\\\", response = null, state = {}, callback = function () {}) {\\\\n  var newState = jQuery.extend(true, {}, state);\\\\n  if (response) {\\\\n    newState.html = response.html;\\\\n    newState.pageTitle = response.pageTitle;\\\\n    document.title = response.pageTitle;\\\\n  } else {\\\\n    newState.html = '';\\\\n    newState.pageTitle = '';\\\\n  }\\\\n  window.history.replaceState(newState, newState.pageTitle, urlPath);\\\\n  callback();\\\\n}\\\\nfunction pushHistoryState(urlPath = \\\\\\\"\\\\\\\", response = null, state = {}, callback = function () {}) {\\\\n  var newState = jQuery.extend(true, {}, state);\\\\n  if (response) {\\\\n    newState.html = response.html;\\\\n    newState.pageTitle = response.pageTitle;\\\\n    document.title = response.pageTitle;\\\\n  } else {\\\\n    newState.html = '';\\\\n    newState.pageTitle = '';\\\\n  }\\\\n  window.history.pushState(newState, newState.pageTitle, urlPath);\\\\n  callback();\\\\n}\\\\nfunction objectToURLParams(obj) {\\\\n  var parts = [];\\\\n  for (var key in obj) {\\\\n    if (obj.hasOwnProperty(key)) {\\\\n      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));\\\\n    }\\\\n  }\\\\n  return \\\\\\\"?\\\\\\\" + parts.join('&');\\\\n}\\\\n\\\\n//ref: https://stackoverflow.com/questions/814613/how-to-read-get-data-from-a-url-using-javascript\\\\nfunction parseURLParams(url, typecast = false, autoParseObjects = false) {\\\\n  var queryStart = url.indexOf(\\\\\\\"?\\\\\\\") + 1,\\\\n    queryEnd = url.indexOf(\\\\\\\"#\\\\\\\") + 1 || url.length + 1,\\\\n    query = url.slice(queryStart, queryEnd - 1),\\\\n    pairs = query.replace(/\\\\\\\\+/g, \\\\\\\" \\\\\\\").split(\\\\\\\"&\\\\\\\"),\\\\n    params = {},\\\\n    i,\\\\n    n,\\\\n    v,\\\\n    nv,\\\\n    nx;\\\\n  if (query === url || query === \\\\\\\"\\\\\\\") return;\\\\n  for (i = 0; i < pairs.length; i++) {\\\\n    nv = pairs[i].split(\\\\\\\"=\\\\\\\", 2);\\\\n    n = decodeURIComponent(nv[0]);\\\\n    v = decodeURIComponent(nv[1]);\\\\n    nx = null;\\\\n    if (typecast) {\\\\n      if (autoParseObjects) {\\\\n        if (n.includes('[')) {\\\\n          //test for array\\\\n          if (n.includes('[]')) {\\\\n            n = n.replace('[]', '');\\\\n            if (!params.hasOwnProperty(n)) params[n] = [];\\\\n          }\\\\n          //test for object\\\\n          else if (n.includes(']')) {\\\\n            var nn = n.split('[', 2);\\\\n            n = nn[0];\\\\n            nx = nn[1].replace(']', '');\\\\n            if (!params.hasOwnProperty(n)) params[n] = {};\\\\n            params[n][nx] = null;\\\\n          }\\\\n        }\\\\n      }\\\\n      //test for number\\\\n      if (!isNaN(v)) v = Number(v);else {\\\\n        //test for boolean\\\\n        v = v === 'true' || (v === 'false' ? false : v);\\\\n        //test for nullable\\\\n        v = v === 'undefined' ? undefined : v === 'null' ? null : v;\\\\n      }\\\\n    }\\\\n    if (!params.hasOwnProperty(n)) {\\\\n      params[n] = v;\\\\n    } else {\\\\n      if (typeof params[n] !== 'object') {\\\\n        params[n] = [params[n]];\\\\n      } else if (params[n] instanceof Array) params[n].push(nv.length === 2 ? v : null);else if (nx != null) params[n][nx] = v;\\\\n    }\\\\n  }\\\\n  /*for(var param of Object.keys(params)){\\\\r\\\\n  \\\\tif(params[param] instanceof Array && params[param].length == 1)\\\\r\\\\n  \\\\t\\\\tparams[param] = params[param][0];\\\\r\\\\n  }*/\\\\n  return params;\\\\n}\\\\n\\\\n///COOKIES///\\\\n//reference: https://www.w3schools.com/js/js_cookies.asp\\\\nfunction checkCookie(cname) {\\\\n  let cookey = getCookie(cname);\\\\n  if (cookey != \\\\\\\"\\\\\\\") return true;\\\\n  return false;\\\\n}\\\\nfunction setCookie(cname, cvalue, exdays = 1) {\\\\n  let d = new Date();\\\\n  d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);\\\\n  let expires = \\\\\\\"expires=\\\\\\\" + d.toUTCString();\\\\n  document.cookie = cname + \\\\\\\"=\\\\\\\" + cvalue + \\\\\\\";\\\\\\\" + expires + \\\\\\\"; path=/\\\\\\\";\\\\n}\\\\nfunction deleteCookie(cname) {\\\\n  document.cookie = cname + \\\\\\\"=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\\\\\\\";\\\\n}\\\\nfunction getCookie(cname) {\\\\n  var name = cname + \\\\\\\"=\\\\\\\";\\\\n  var decodedCookie = decodeURIComponent(document.cookie);\\\\n  var ca = decodedCookie.split(';');\\\\n  for (var i = 0; i < ca.length; i++) {\\\\n    var c = ca[i];\\\\n    while (c.charAt(0) == ' ') {\\\\n      c = c.substring(1);\\\\n    }\\\\n    if (c.indexOf(name) == 0) {\\\\n      return c.substring(name.length, c.length);\\\\n    }\\\\n  }\\\\n  return \\\\\\\"\\\\\\\";\\\\n}\\\\n///VERIFY DATA TYPE///\\\\nfunction isInt(val) {\\\\n  return isNumber(val) && Math.trunc(val) === val;\\\\n}\\\\nfunction isNumber(val) {\\\\n  return !isNaN(Number(val));\\\\n}\\\\nfunction isArray(arr) {\\\\n  return typeof arr === 'object' && arr instanceof Array;\\\\n}\\\\nfunction isString(str) {\\\\n  return typeof str === 'string';\\\\n}\\\\nfunction isFunction(func) {\\\\n  return typeof func === 'function' || func instanceof Function;\\\\n}\\\\nfunction isObject(object) {\\\\n  return object != null && typeof object === 'object';\\\\n}\\\\nfunction isInRange(num, min, max, inclusive = true) {\\\\n  if (inclusive) return num >= min && num <= max;else return num > min && num < max;\\\\n}\\\\nfunction isJSON(str) {\\\\n  if (!isString(str)) {\\\\n    str = JSON.stringify(str);\\\\n  }\\\\n  let obj = null;\\\\n  try {\\\\n    obj = JSON.parse(str);\\\\n  } catch (e) {\\\\n    return false;\\\\n  }\\\\n  if (isObject(obj)) return true;\\\\n  return false;\\\\n}\\\\nfunction link_is_external(link_element, _location = window.location) {\\\\n  return link_element.host !== _location.host;\\\\n}\\\\nfunction isExternalURLFast(url) {\\\\n  var match = url.match(/^([^:\\\\\\\\/?#]+:)?(?:\\\\\\\\/\\\\\\\\/([^\\\\\\\\/?#]*))?([^?#]+)?(\\\\\\\\?[^#]*)?(#.*)?/);\\\\n  if (typeof match[1] === \\\\\\\"string\\\\\\\" && match[1].length > 0 && match[1].toLowerCase() !== location.protocol) return true;\\\\n  if (typeof match[2] === \\\\\\\"string\\\\\\\" && match[2].length > 0 && match[2].replace(new RegExp(\\\\\\\":(\\\\\\\" + {\\\\n    \\\\\\\"http:\\\\\\\": 80,\\\\n    \\\\\\\"https:\\\\\\\": 443\\\\n  }[location.protocol] + \\\\\\\")?$\\\\\\\"), \\\\\\\"\\\\\\\") !== location.host) return true;\\\\n  return false;\\\\n}\\\\nfunction isExternalURL(url) {\\\\n  try {\\\\n    if (typeof URL === 'undefined') {}\\\\n  } catch (e) {\\\\n    console.debug(e);\\\\n  }\\\\n  var res = false;\\\\n  try {\\\\n    res = new URL(url).origin !== location.origin;\\\\n  } catch (e) {\\\\n    return false;\\\\n  }\\\\n  return res;\\\\n}\\\\nfunction JSONobjectsAreEqual(objA, objB) {\\\\n  var jsonA = JSON.stringify(objA);\\\\n  var jsonB = JSON.stringify(objB);\\\\n  if (jsonA === jsonB) return true;\\\\n  return false;\\\\n}\\\\n\\\\n///GENERATING RANDOM VALUE///\\\\n\\\\nfunction randomId(_prefix = '', _suffix = '') {\\\\n  return _prefix + Math.random().toString(36).substr(2, 9) + _suffix;\\\\n}\\\\nfunction randomID(_prefix = '', _suffix = '', _length = 9) {\\\\n  return _prefix + randomString(9) + _suffix;\\\\n}\\\\nfunction hexadecimalID(_len = 16, _pow = 4) {\\\\n  return Math.floor((1 + Math.random()) * Math.pow(_len, _pow)).toString(16).substring(1);\\\\n}\\\\nfunction randomString(length, chars) {\\\\n  if (!chars) chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';else chars = String(chars);\\\\n  var result = '';\\\\n  for (var i = length; i > 0; --i) result += chars[Math.floor(Math.random() * chars.length)];\\\\n  return result;\\\\n}\\\\nfunction randomCharFrom(str) {\\\\n  return randomString(1, str);\\\\n}\\\\nfunction rndInt(min, max) {\\\\n  return Math.floor(Math.random() * (max - min + 1)) + min;\\\\n}\\\\nfunction randomItemFrom(arr) {\\\\n  return arr[rndInt(0, arr.length - 1)];\\\\n}\\\\nfunction safeStringify(obj) {\\\\n  let cache = [];\\\\n  let s = JSON.stringify(obj, (key, value) => {\\\\n    if (isObject(value)) {\\\\n      // Duplicate reference found, discard key\\\\n      if (cache.includes(value)) return;\\\\n      // Store value in our collection\\\\n      cache.push(value);\\\\n    }\\\\n    return value;\\\\n  });\\\\n  cache = null; // Enable garbage collection\\\\n\\\\n  return s;\\\\n}\\\\n\\\\n///HASHING///\\\\nfunction hash32(str) {\\\\n  var hash = 0,\\\\n    i,\\\\n    chr;\\\\n  str = String(str);\\\\n  if (str.length === 0) return hash;\\\\n  for (i = 0; i < str.length; i++) {\\\\n    chr = str.charCodeAt(i);\\\\n    hash = (hash << 5) - hash + chr;\\\\n    hash |= 0; // Convert to 32bit integer\\\\n  }\\\\n\\\\n  return String(hash);\\\\n}\\\\nfunction hash64(str) {\\\\n  var h1 = hash32(str); // returns 32 bit (as 8 byte hex string)\\\\n  return h1 + hash32(h1 + str); // 64 bit (as 16 byte hex string)\\\\n}\\\\n\\\\nfunction hash128(str) {\\\\n  var h1 = hash64(str); // returns 64 bit (as 16 byte hex string)\\\\n  return h1 + hash64(h1 + str); // 128 bit (as 32 byte hex string)\\\\n}\\\\n\\\\n//OTHER//\\\\nfunction stringTrimToLength(_str, _len) {\\\\n  if (_len == null) _len = String(_str).length;\\\\n  _str = String(_str);\\\\n  return _str.substring(0, _len);\\\\n}\\\\nfunction jsonFix(str) {\\\\n  str = String(str);\\\\n  // let regex = /\\\\\\\\,(?=\\\\\\\\s*?[\\\\\\\\}\\\\\\\\]])/g;\\\\n  let regex = /\\\\\\\\,(?!\\\\\\\\s*?[\\\\\\\\{\\\\\\\\[\\\\\\\\\\\\\\\"\\\\\\\\'\\\\\\\\w])/g;\\\\n  var newStr = str.replace(regex, '');\\\\n  return newStr;\\\\n}\\\\nfunction deg2rad(deg) {\\\\n  var res = deg * Math.PI / 180;\\\\n  return res;\\\\n}\\\\nfunction rad2deg(rad) {\\\\n  var res = rad * 180 / Math.PI;\\\\n  return res;\\\\n}\\\\nfunction stepify(value, step) {\\\\n  if (step == 0) return value;\\\\n  if (step == Infinity) return 1;\\\\n  return Math.round((value + Number.EPSILON) / step) * step;\\\\n}\\\\nfunction splitStringByLength(str, len) {\\\\n  var parts = [];\\\\n  for (var i = 0; i < str.length; i += len) {\\\\n    parts.push(str.substring(i, i + len));\\\\n  }\\\\n  return parts;\\\\n}\\\\nfunction sanitizeString(str) {\\\\n  str = str.replace(/[^a-z0-9áéíóúñü \\\\\\\\.,_-]/gim, \\\\\\\"\\\\\\\");\\\\n  return str.trim();\\\\n}\\\\nfunction validateEmail(email) {\\\\n  return String(email).toLowerCase().match(/^(([^<>()[\\\\\\\\]\\\\\\\\\\\\\\\\.,;:\\\\\\\\s@\\\\\\\"]+(\\\\\\\\.[^<>()[\\\\\\\\]\\\\\\\\\\\\\\\\.,;:\\\\\\\\s@\\\\\\\"]+)*)|(\\\\\\\".+\\\\\\\"))@((\\\\\\\\[[0-9]{1,3}\\\\\\\\.[0-9]{1,3}\\\\\\\\.[0-9]{1,3}\\\\\\\\.[0-9]{1,3}\\\\\\\\])|(([a-zA-Z\\\\\\\\-0-9]+\\\\\\\\.)+[a-zA-Z]{2,}))$/);\\\\n}\\\\n//https://stackoverflow.com/questions/7744912/making-a-javascript-string-sql-friendly\\\\nfunction mysql_real_escape_string(str) {\\\\n  return str.replace(/[\\\\\\\\0\\\\\\\\x08\\\\\\\\x09\\\\\\\\x1a\\\\\\\\n\\\\\\\\r\\\\\\\"'\\\\\\\\\\\\\\\\\\\\\\\\%]/g, function (char) {\\\\n    switch (char) {\\\\n      case \\\\\\\"\\\\\\\\0\\\\\\\":\\\\n        return \\\\\\\"\\\\\\\\\\\\\\\\0\\\\\\\";\\\\n      case \\\\\\\"\\\\\\\\x08\\\\\\\":\\\\n        return \\\\\\\"\\\\\\\\\\\\\\\\b\\\\\\\";\\\\n      case \\\\\\\"\\\\\\\\x09\\\\\\\":\\\\n        return \\\\\\\"\\\\\\\\\\\\\\\\t\\\\\\\";\\\\n      case \\\\\\\"\\\\\\\\x1a\\\\\\\":\\\\n        return \\\\\\\"\\\\\\\\\\\\\\\\z\\\\\\\";\\\\n      case \\\\\\\"\\\\\\\\n\\\\\\\":\\\\n        return \\\\\\\"\\\\\\\\\\\\\\\\n\\\\\\\";\\\\n      case \\\\\\\"\\\\\\\\r\\\\\\\":\\\\n        return \\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\";\\\\n      case \\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\":\\\\n      case \\\\\\\"'\\\\\\\":\\\\n      case \\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\":\\\\n      case \\\\\\\"%\\\\\\\":\\\\n        return \\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\" + char;\\\\n      // prepends a backslash to backslash, percent, and double/single quotes\\\\n      default:\\\\n        return char;\\\\n    }\\\\n  });\\\\n}\\\\n\\\\n///OBJECTS\\\\n\\\\nfunction areSimilar(objA, objB) {\\\\n  if (objA == objB) return true;\\\\n  if (isObject(objA) && isObject(objB)) {\\\\n    objA = JSON.parse(JSON.stringify(objA));\\\\n    objB = JSON.parse(JSON.stringify(objB));\\\\n    for (let k of Object.keys(objA)) {\\\\n      if (!(k in objB)) return false;\\\\n      if (!areSimilar(objA[k], obj[k])) return false;\\\\n    }\\\\n    return true;\\\\n  } else {\\\\n    if (typeof objA === typeof objB) {\\\\n      return objA === objB;\\\\n    }\\\\n  }\\\\n  return false;\\\\n}\\\\n\\\\n///ARRAYS\\\\n\\\\nfunction hardPush(arr, item, compareProps) {\\\\n  if (!arr || !(arr instanceof Array)) return false;\\\\n  if (!item) return false;\\\\n  if (!arr.length) {\\\\n    arr.push(item);\\\\n    return true;\\\\n  }\\\\n  if (arr.indexOf(item) >= 0) return false;\\\\n  for (var i = 0; i < arr.length; i++) {\\\\n    var arrItem = arr[i];\\\\n    if (isObject(arrItem) && isObject(item)) {\\\\n      if (compareProps && isArray(compareProps)) {\\\\n        for (let prop of compareProps) {\\\\n          if (prop in arrItem && areSimilar(arrItem[prop], item[prop])) {\\\\n            return false;\\\\n          }\\\\n        }\\\\n      }\\\\n    } else if (arrItem === item) {\\\\n      return false;\\\\n    }\\\\n  }\\\\n  arr.push(item);\\\\n  return true;\\\\n}\\\\nfunction shallowEqual(object1, object2) {\\\\n  let keys1 = Object.keys(object1);\\\\n  let keys2 = Object.keys(object2);\\\\n  if (keys1.length !== keys2.length) {\\\\n    return false;\\\\n  }\\\\n  for (let key of keys1) {\\\\n    if (object1[key] !== object2[key]) {\\\\n      return false;\\\\n    }\\\\n  }\\\\n  return true;\\\\n}\\\\nfunction deepEqual(object1, object2) {\\\\n  let keys1 = Object.keys(object1);\\\\n  let keys2 = Object.keys(object2);\\\\n  if (keys1.length !== keys2.length) {\\\\n    return false;\\\\n  }\\\\n  for (let key of keys1) {\\\\n    let val1 = object1[key];\\\\n    let val2 = object2[key];\\\\n    let areObjects = isObject(val1) && isObject(val2);\\\\n    if (areObjects && !deepEqual(val1, val2) || !areObjects && val1 !== val2) {\\\\n      return false;\\\\n    }\\\\n  }\\\\n  return true;\\\\n}\\\\nfunction findItemIndex(arr, item) {\\\\n  if (!arr || !(arr instanceof Array)) return null;\\\\n  if (!item) return null;\\\\n  for (let i = 0; i < arr.length; i++) {\\\\n    let arrItem = arr[i];\\\\n    if (isObject(arrItem) && isObject(item)) if (shallowEqual(arrItem, item)) return i;else if (arrItem === item) return i;\\\\n  }\\\\n  return false;\\\\n}\\\\nfunction findItem(arr, item) {\\\\n  var res = findItemIndex(arr, item);\\\\n  if (res === false) return false;\\\\n  return true;\\\\n}\\\\nfunction arrayRemove(arr, item) {\\\\n  var res = arr.indexOf(item);\\\\n  if (res < 0) return false;\\\\n  let x = arr.splice(res, 1);\\\\n  return x.length > 0;\\\\n}\\\\nfunction findItemObject(arr, item, compareProperties = null) {\\\\n  var res = findItemObjectIndex(arr, item, compareProperties);\\\\n  if (res === false) return false;\\\\n  return true;\\\\n}\\\\nfunction findItemObjectIndex(arr, item, compareProperties = null) {\\\\n  if (!arr || !(arr instanceof Array)) return false;\\\\n  if (!item) return false;\\\\n  if (arr.length == 0) {\\\\n    return false;\\\\n  }\\\\n  for (var i = 0; i < arr.length; i++) {\\\\n    let arrItem = arr[i];\\\\n    if (arrItem instanceof Object && item instanceof Object) {\\\\n      if (compareProperties && compareProperties instanceof Array) {\\\\n        for (let pproperty of compareProperties) {\\\\n          if (arrItem.hasOwnProperty(pproperty) && arrItem[pproperty] === item[pproperty]) return i;\\\\n        }\\\\n      } else if (shallowEqual(arrItem, item)) return i;\\\\n    } else if (arrItem === item) return i;\\\\n  }\\\\n  return false;\\\\n}\\\\nfunction getObjectFromArray(arr, properties) {\\\\n  if (!arr || !(arr instanceof Array)) return false;\\\\n  if (!properties) return false;\\\\n  if (arr.length == 0) {\\\\n    return false;\\\\n  }\\\\n  var item = properties;\\\\n  var compareProperties = Object.keys(item);\\\\n  for (var i = 0; i < arr.length; i++) {\\\\n    var arrItem = arr[i];\\\\n    if (arrItem instanceof Object && item instanceof Object) {\\\\n      if (compareProperties && compareProperties instanceof Array) {\\\\n        for (let prop of compareProperties) {\\\\n          if (arrItem.hasOwnProperty(prop) && arrItem[prop] === item[prop]) return arrItem;\\\\n        }\\\\n      } else if (shallowEqual(arrItem, item)) return arrItem;\\\\n    } else if (arrItem === item) return arrItem;\\\\n  }\\\\n  return false;\\\\n}\\\\nfunction getClosestPathInCircle(arr, _from, _to, bias = 0) {\\\\n  if (!(arr instanceof Array)) {\\\\n    return [];\\\\n  }\\\\n  if (_from < 0 || _from >= arr.length) {\\\\n    return [];\\\\n  }\\\\n  if (_to < 0 || _to >= arr.length) {\\\\n    return [];\\\\n  }\\\\n  let iL = iR = _from;\\\\n  let arrL = [],\\\\n    arrR = [];\\\\n  let arrX;\\\\n  while (arrL.length < arr.length) {\\\\n    let _i = mod(iL, arr.length);\\\\n    arrL.push(arr[_i]);\\\\n    if (Math.abs(_i) == _to) break;\\\\n    iL--;\\\\n  }\\\\n  while (arrR.length < arr.length) {\\\\n    let _i = mod(iR, arr.length);\\\\n    arrR.push(arr[_i]);\\\\n    if (Math.abs(_i) == _to) break;\\\\n    iR++;\\\\n  }\\\\n  if (Math.abs(arrL.length) < Math.abs(arrR.length)) {\\\\n    arrX = arrL;\\\\n  } else if (Math.abs(arrL.length) > Math.abs(arrR.length)) {\\\\n    arrX = arrR;\\\\n  } else {\\\\n    if (bias > 0) arrX = arrR;else arrX = arrL;\\\\n  }\\\\n  return arrX;\\\\n}\\\\nfunction roundTo(num, step) {\\\\n  if (step == 0) return num;\\\\n  if (isInfinity(step)) return Infinity;\\\\n  let invStep = Math.pow(step, -1);\\\\n  let invMiniStep = Math.pow(step / 10, -1);\\\\n  let initNum = Math.round(num * invMiniStep) / invMiniStep;\\\\n  let init = Math.round(initNum * invStep) / invStep;\\\\n  // let res = init;\\\\n  let res = Math.round((init + Number.EPSILON) * invStep) / invStep;\\\\n  return res;\\\\n}\\\\n\\\\n//# sourceURL=webpack://MY/./lib/cjs/src/myHelperFunctions.js?\\\");\\n\\n/***/ })\\n\\n/******/ \\t});\\n/************************************************************************/\\n/******/ \\t// The module cache\\n/******/ \\tvar __webpack_module_cache__ = {};\\n/******/ \\t\\n/******/ \\t// The require function\\n/******/ \\tfunction __nested_webpack_require_31724__(moduleId) {\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tvar cachedModule = __webpack_module_cache__[moduleId];\\n/******/ \\t\\tif (cachedModule !== undefined) {\\n/******/ \\t\\t\\treturn cachedModule.exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = __webpack_module_cache__[moduleId] = {\\n/******/ \\t\\t\\t// no module.id needed\\n/******/ \\t\\t\\t// no module.loaded needed\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/ \\t\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_31724__);\\n/******/ \\t\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/ \\t\\n/************************************************************************/\\n/******/ \\t\\n/******/ \\t// startup\\n/******/ \\t// Load entry module and return exports\\n/******/ \\t// This entry module can't be inlined because the eval devtool is used.\\n/******/ \\tvar __webpack_exports__ = __nested_webpack_require_31724__(\\\"./lib/cjs/index.js\\\");\\n/******/ \\t\\n/******/ \\treturn __webpack_exports__;\\n/******/ })()\\n;\\n});\\n\\n//# sourceURL=webpack://VECTOR2/./node_modules/@catsums/my/lib/umd/index.dev.js?\");\n\n/***/ }),\n\n/***/ \"./lib/cjs/index.js\":\n/*!**************************!*\\\n  !*** ./lib/cjs/index.js ***!\n  \\**************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nmodule.exports = __webpack_require__(/*! ./src */ \\\"./lib/cjs/src/index.js\\\");\\n\\n//# sourceURL=webpack://VECTOR2/./lib/cjs/index.js?\");\n\n/***/ }),\n\n/***/ \"./lib/cjs/src/Rect2/Rect2.js\":\n/*!************************************!*\\\n  !*** ./lib/cjs/src/Rect2/Rect2.js ***!\n  \\************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", ({\\n  value: true\\n}));\\nexports.Rect2 = void 0;\\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \\\"./node_modules/@catsums/my/lib/umd/index.dev.js\\\"));\\nvar _Vector = __webpack_require__(/*! ../Vector2/Vector2 */ \\\"./lib/cjs/src/Vector2/Vector2.js\\\");\\nfunction _getRequireWildcardCache(nodeInterop) {\\n  if (typeof WeakMap !== \\\"function\\\") return null;\\n  var cacheBabelInterop = new WeakMap();\\n  var cacheNodeInterop = new WeakMap();\\n  return (_getRequireWildcardCache = function (nodeInterop) {\\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\\n  })(nodeInterop);\\n}\\nfunction _interopRequireWildcard(obj, nodeInterop) {\\n  if (!nodeInterop && obj && obj.__esModule) {\\n    return obj;\\n  }\\n  if (obj === null || typeof obj !== \\\"object\\\" && typeof obj !== \\\"function\\\") {\\n    return {\\n      default: obj\\n    };\\n  }\\n  var cache = _getRequireWildcardCache(nodeInterop);\\n  if (cache && cache.has(obj)) {\\n    return cache.get(obj);\\n  }\\n  var newObj = {};\\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\\n  for (var key in obj) {\\n    if (key !== \\\"default\\\" && Object.prototype.hasOwnProperty.call(obj, key)) {\\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\\n      if (desc && (desc.get || desc.set)) {\\n        Object.defineProperty(newObj, key, desc);\\n      } else {\\n        newObj[key] = obj[key];\\n      }\\n    }\\n  }\\n  newObj.default = obj;\\n  if (cache) {\\n    cache.set(obj, newObj);\\n  }\\n  return newObj;\\n}\\nclass Rect2 {\\n  position;\\n  size;\\n  static EQUALS(r1, r2, p) {\\n    if (r1 === r2) return true;\\n    if (!r1 || !r2) return false;\\n    if (_Vector.Vector2.EQUALS(r1.position, r2.position, p) && _Vector.Vector2.EQUALS(r1.size, r2.size, p)) return true;\\n    return false;\\n  }\\n  static COMBINE(rects) {\\n    let pts = [];\\n    for (let r of rects) {\\n      if (r instanceof Rect2) {\\n        pts = pts.concat(r.getCorners());\\n      }\\n    }\\n    return Rect2.from(pts);\\n  }\\n  static from(pts) {\\n    return Rect2.getFromPoints(pts);\\n  }\\n  static getFromPoints(points) {\\n    if (!MY.isArray(points)) return null;\\n    let xMin, xMax, yMin, yMax;\\n    xMax = yMax = -Infinity;\\n    xMin = yMin = Infinity;\\n    for (let pt of points) {\\n      pt = new _Vector.Vector2(pt);\\n      if (xMin == null || xMin > pt.x) xMin = pt.x;\\n      if (yMin == null || yMin > pt.y) yMin = pt.y;\\n      if (xMax == null || xMax < pt.x) xMax = pt.x;\\n      if (yMax == null || yMax < pt.y) yMax = pt.y;\\n    }\\n    let w = xMax - xMin;\\n    let h = yMax - yMin;\\n    return new Rect2(xMin, yMin, w, h);\\n  }\\n  get start() {\\n    return new _Vector.Vector2(this.left, this.top);\\n  }\\n  get end() {\\n    return new _Vector.Vector2(this.right, this.bottom);\\n  }\\n  get center() {\\n    return _Vector.Vector2.MIDPOINT([this.start, this.end]);\\n  }\\n  get extents() {\\n    return _Vector.Vector2.SUBTRACT(this.center, this.start);\\n  }\\n  get topLeft() {\\n    return new _Vector.Vector2(this.left, this.top);\\n  }\\n  get topRight() {\\n    return new _Vector.Vector2(this.right, this.top);\\n  }\\n  get bottomLeft() {\\n    return new _Vector.Vector2(this.left, this.bottom);\\n  }\\n  get bottomRight() {\\n    return new _Vector.Vector2(this.right, this.bottom);\\n  }\\n  get x() {\\n    return this.position.x;\\n  }\\n  set x(n) {\\n    if (MY.isNumber(n)) this.position.x = n;\\n  }\\n  get y() {\\n    return this.position.y;\\n  }\\n  set y(n) {\\n    if (MY.isNumber(n)) this.position.y = n;\\n  }\\n  get w() {\\n    return this.size.x;\\n  }\\n  set w(n) {\\n    if (MY.isNumber(n)) this.size.x = n;\\n  }\\n  get h() {\\n    return this.size.y;\\n  }\\n  set h(n) {\\n    if (MY.isNumber(n)) this.size.y = n;\\n  }\\n  get width() {\\n    return this.w;\\n  }\\n  set width(n) {\\n    this.w = n;\\n  }\\n  get height() {\\n    return this.h;\\n  }\\n  set height(n) {\\n    this.h = n;\\n  }\\n  get left() {\\n    return this.x;\\n  }\\n  set left(n) {\\n    if (MY.isNumber(n)) {\\n      this.w = this.right - n;\\n      this.x = n;\\n    }\\n  }\\n  get top() {\\n    return this.y;\\n  }\\n  set top(n) {\\n    if (MY.isNumber(n)) {\\n      this.h = this.bottom - n;\\n      this.y = n;\\n    }\\n  }\\n  get right() {\\n    return this.x + this.w;\\n  }\\n  set right(n) {\\n    if (MY.isNumber(n)) {\\n      this.w = n - this.left;\\n    }\\n  }\\n  get bottom() {\\n    return this.y + this.h;\\n  }\\n  set bottom(n) {\\n    if (MY.isNumber(n)) {\\n      this.h = n - this.top;\\n    }\\n  }\\n  constructor(p, s, w, h) {\\n    if (p instanceof Rect2) {\\n      this.position = new _Vector.Vector2(p.position);\\n      this.size = new _Vector.Vector2(p.size);\\n    } else if (MY.isObject(p) && 'x' in p && 'y' in p && 'w' in p && 'h' in p) {\\n      this.position = new _Vector.Vector2(p.x, p.y);\\n      this.size = new _Vector.Vector2(p.w, p.h);\\n    } else if (MY.isObject(p) && 'top' in p && 'left' in p && 'right' in p && 'bottom' in p) {\\n      this.position = new _Vector.Vector2(p.left, p.top);\\n      this.size = new _Vector.Vector2(p.right - p.left, p.bottom - p.top);\\n    } else if (MY.isObject(p) && 't' in p && 'l' in p && 'r' in p && 'b' in p) {\\n      this.position = new _Vector.Vector2(p.l, p.t);\\n      this.size = new _Vector.Vector2(p.r - p.l, p.b - p.t);\\n    } else if (MY.isNumber(p) && MY.isNumber(s) && MY.isNumber(w) && MY.isNumber(h)) {\\n      this.position = new _Vector.Vector2(p, s);\\n      this.size = new _Vector.Vector2(w, h);\\n    } else if (p instanceof _Vector.Vector2 && s instanceof _Vector.Vector2) {\\n      this.position = new _Vector.Vector2(p);\\n      this.size = new _Vector.Vector2(s);\\n    } else {\\n      this.position = new _Vector.Vector2();\\n      this.size = new _Vector.Vector2();\\n    }\\n  }\\n  equals(other, p) {\\n    return Rect2.EQUALS(this, other, p);\\n  }\\n  abs() {\\n    return new Rect2(this.position, this.size.abs());\\n  }\\n  containsPoint(v) {\\n    if (v.x < this.left || v.x > this.right || v.y < this.top || v.y > this.bottom) return false;\\n    return true;\\n  }\\n  getIntersectWith(other, threshold = 0) {\\n    if (!this.intersectsWith(other, threshold)) return null;\\n    let yMin = this.top > other.top ? this.top : other.top;\\n    let yMax = this.bottom < other.bottom ? this.bottom : other.bottom;\\n    let xMin = this.left > other.left ? this.left : other.left;\\n    let xMax = this.right < other.right ? this.right : other.right;\\n    return new Rect2(new _Vector.Vector2(xMin, yMin), new _Vector.Vector2(xMax - xMin, yMax - yMin));\\n  }\\n  intersectsWith(other, threshold = 0) {\\n    if (this.right + threshold < other.left || this.left - threshold > other.right || this.bottom + threshold < other.top || this.top - threshold > other.bottom) return false;\\n    return true;\\n  }\\n  touches(other, threshold = 0) {\\n    if (this.right + threshold == other.left || this.left - threshold == other.right || this.bottom + threshold == other.top || this.top - threshold == other.bottom) return true;\\n    return false;\\n  }\\n  combine(other) {\\n    return Rect2.COMBINE([this, other]);\\n  }\\n  getCorners() {\\n    return [this.topLeft, this.topRight, this.bottomRight, this.bottomLeft];\\n  }\\n  clampPoints(pts) {\\n    let rect = this;\\n    let newPts = pts.map(pt => {\\n      pt = new _Vector.Vector2(pt);\\n      if (pt.y > rect.bottom) pt.y = rect.bottom;\\n      if (pt.x > rect.right) pt.x = rect.right;\\n      if (pt.y < rect.top) pt.y = rect.top;\\n      if (pt.x < rect.left) pt.x = rect.left;\\n      return pt;\\n    });\\n    return newPts;\\n  }\\n  asObject() {\\n    let rect = {};\\n    rect = {\\n      x: this.x,\\n      y: this.y,\\n      w: this.w,\\n      h: this.h,\\n      get top() {\\n        return rect.y;\\n      },\\n      get bottom() {\\n        return rect.y + rect.h;\\n      },\\n      get left() {\\n        return rect.x;\\n      },\\n      get right() {\\n        return rect.x + rect.w;\\n      }\\n    };\\n    return rect;\\n  }\\n  asArray() {\\n    return [this.x, this.y, this.w, this.h];\\n  }\\n  toString() {\\n    var out = `Rect2( ${this.position} ${this.size})`;\\n    return out;\\n  }\\n  toJSON() {\\n    return {\\n      position: this.position?.toJSON() || null,\\n      size: this.size?.toJSON() || null\\n    };\\n  }\\n}\\nexports.Rect2 = Rect2;\\n\\n//# sourceURL=webpack://VECTOR2/./lib/cjs/src/Rect2/Rect2.js?\");\n\n/***/ }),\n\n/***/ \"./lib/cjs/src/Transform2/Transform2.js\":\n/*!**********************************************!*\\\n  !*** ./lib/cjs/src/Transform2/Transform2.js ***!\n  \\**********************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", ({\\n  value: true\\n}));\\nexports.Transform2 = void 0;\\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \\\"./node_modules/@catsums/my/lib/umd/index.dev.js\\\"));\\nvar _Vector = __webpack_require__(/*! ../Vector2/Vector2 */ \\\"./lib/cjs/src/Vector2/Vector2.js\\\");\\nfunction _getRequireWildcardCache(nodeInterop) {\\n  if (typeof WeakMap !== \\\"function\\\") return null;\\n  var cacheBabelInterop = new WeakMap();\\n  var cacheNodeInterop = new WeakMap();\\n  return (_getRequireWildcardCache = function (nodeInterop) {\\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\\n  })(nodeInterop);\\n}\\nfunction _interopRequireWildcard(obj, nodeInterop) {\\n  if (!nodeInterop && obj && obj.__esModule) {\\n    return obj;\\n  }\\n  if (obj === null || typeof obj !== \\\"object\\\" && typeof obj !== \\\"function\\\") {\\n    return {\\n      default: obj\\n    };\\n  }\\n  var cache = _getRequireWildcardCache(nodeInterop);\\n  if (cache && cache.has(obj)) {\\n    return cache.get(obj);\\n  }\\n  var newObj = {};\\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\\n  for (var key in obj) {\\n    if (key !== \\\"default\\\" && Object.prototype.hasOwnProperty.call(obj, key)) {\\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\\n      if (desc && (desc.get || desc.set)) {\\n        Object.defineProperty(newObj, key, desc);\\n      } else {\\n        newObj[key] = obj[key];\\n      }\\n    }\\n  }\\n  newObj.default = obj;\\n  if (cache) {\\n    cache.set(obj, newObj);\\n  }\\n  return newObj;\\n}\\nclass Transform2 {\\n  _position;\\n  _rotation;\\n  _scale;\\n  _skew;\\n  _anchor;\\n  _parent;\\n  _childs = [];\\n  static EQUALS(t1, t2, p) {\\n    if (t1 === t2) return true;\\n    if (!t2 || !t2) return false;\\n    if (_Vector.Vector2.EQUALS(t1.position, t2.position, p) && _Vector.Vector2.EQUALS(t1.scale, t2.scale, p) && _Vector.Vector2.EQUALS(t1.skew, t2.skew, p) && _Vector.Vector2.EQUALS(t1.anchor, t2.anchor, p) && MY.roundTo(r, p) === MY.roundTo(r, p)) return true;\\n    return false;\\n  }\\n  static INVERSE(t) {\\n    let p = _Vector.Vector2.NEG(t.position);\\n    let s = _Vector.Vector2.INVERSE(t.scale);\\n    let r = -t.rotation;\\n    let k = _Vector.Vector2.NEG(t.skew);\\n    let a = t.anchor;\\n    return new Transform2(p, r, s, k, a);\\n  }\\n  get parent() {\\n    return this._parent;\\n  }\\n  set parent(x) {\\n    if (x instanceof Transform2) this._parent = x;\\n  }\\n  get position() {\\n    return this._position;\\n  }\\n  set position(x) {\\n    if (x instanceof _Vector.Vector2) this._position = new _Vector.Vector2(x);\\n  }\\n  get rotation() {\\n    return this._rotation;\\n  }\\n  set rotation(x) {\\n    if (MY.isNumber(x)) this._rotation = Number(x);\\n  }\\n  get scale() {\\n    return this._scale;\\n  }\\n  set scale(x) {\\n    if (x instanceof _Vector.Vector2) this._scale = new _Vector.Vector2(x);\\n  }\\n  get skew() {\\n    return this._skew;\\n  }\\n  set skew(x) {\\n    if (x instanceof _Vector.Vector2) this._skew = new _Vector.Vector2(x);\\n  }\\n  get anchor() {\\n    return this._anchor;\\n  }\\n  set anchor(x) {\\n    if (x instanceof _Vector.Vector2) this._anchor = new _Vector.Vector2(x);\\n  }\\n  get children() {\\n    return this._childs;\\n  }\\n  get childs() {\\n    return this.children;\\n  }\\n  get a() {\\n    return this.scale.x * (Math.cos(this.rotation) - Math.sin(this.rotation) * Math.tan(this.skew.x));\\n  }\\n  get b() {\\n    return this.scale.y * (Math.sin(this.rotation) + Math.cos(this.rotation) * Math.tan(this.skew.y));\\n  }\\n  get c() {\\n    return this.scale.x * (Math.cos(this.rotation) * Math.tan(this.skew.x) - Math.sin(this.rotation));\\n  }\\n  get d() {\\n    return this.scale.y * (Math.sin(this.rotation) * Math.tan(this.skew.y) + Math.cos(this.rotation));\\n  }\\n  get tx() {\\n    return this.position.x;\\n  }\\n  get ty() {\\n    return this.position.y;\\n  }\\n  get matrix() {\\n    return [[this.a, this.c, this.tx], [this.b, this.d, this.ty], [0, 0, 1]];\\n  }\\n  constructor(p = _Vector.Vector2.ZERO, r = 0, s = _Vector.Vector2.ONE, k = _Vector.Vector2.ZERO, a = _Vector.Vector2.ZERO) {\\n    if (p instanceof Transform2) {\\n      this.position = p.position;\\n      this.rotation = p.rotation;\\n      this.scale = p.scale;\\n      this.skew = p.skew;\\n      this.anchor = p.anchor;\\n    } else {\\n      this.position = p;\\n      this.rotation = r;\\n      this.scale = s;\\n      this.skew = k;\\n      this.anchor = a;\\n    }\\n  }\\n  inverted() {\\n    return Transform2.INVERSE(this);\\n  }\\n  setParent(x) {\\n    if (!(x instanceof Transform2)) return;\\n    if (x == this) return;\\n    if (this.parent) {\\n      this.parent.removeChild(this);\\n    }\\n    this.parent = x;\\n  }\\n  addChild(x) {\\n    if (!(x instanceof Transform2)) return;\\n    if (x == this) return;\\n    x.setParent(this);\\n    this._childs.push(x);\\n  }\\n  removeChild(x) {\\n    if (x == this) return null;\\n    let ind;\\n    let out = null;\\n    if (x instanceof Transform2) {\\n      ind = this._childs.indexOf(x);\\n    } else if (MY.isNumber(x)) {\\n      ind = x;\\n    }\\n    if (ind >= 0 && ind < this._childs.length) {\\n      out = this._childs[ind];\\n      this._childs.splice(ind, 1);\\n    }\\n    return out;\\n  }\\n  getGlobalTransform() {\\n    let parentTransform = this.parent?.getGlobalTransform() || new Transform2();\\n    let pt = parentTransform;\\n    let p = _Vector.Vector2.ADD(pt.position, this.position);\\n    let r = pt.rotation + this.rotation;\\n    let s = _Vector.Vector2.MULTIPLY(pt.scale, this.scale);\\n    let k = new _Vector.Vector2(Math.tan(Math.atan(this.skew.x) + Math.atan(pt.skew.x)), Math.tan(Math.atan(this.skew.y) + Math.atan(pt.skew.y)));\\n    let a = pt.applyTransform(this.anchor, pt.anchor);\\n    // let a = Vector2.ADD(pt.anchor, this.anchor);\\n\\n    return new Transform2(p, r, s, k, a);\\n  }\\n  applyGlobalTransform(pt, anchor = this.anchor, order = ['S', 'K', 'R', 'T']) {\\n    let globalTrans = this.getGlobalTransform();\\n    let newPt = new _Vector.Vector2(pt);\\n\\n    // newPt = Vector2.SUBTRACT(newPt, this.anchor);\\n    newPt = globalTrans.applyTransform(pt, anchor, order);\\n    // newPt = Vector2.ADD(newPt, this.anchor);\\n\\n    return newPt;\\n  }\\n  applyTranslate(pt, anchor = this.anchor) {\\n    let newPt = new _Vector.Vector2(pt);\\n    newPt = _Vector.Vector2.SUBTRACT(newPt, anchor);\\n    newPt = _Vector.Vector2.ADD(newPt, this.position);\\n    newPt = _Vector.Vector2.ADD(newPt, anchor);\\n    return newPt;\\n  }\\n  applyRotate(pt, anchor = this.anchor) {\\n    let newPt = new _Vector.Vector2(pt);\\n    newPt = _Vector.Vector2.SUBTRACT(newPt, anchor);\\n    newPt = newPt.rotated(_Vector.Vector2.ZERO, this.rotation);\\n    newPt = _Vector.Vector2.ADD(newPt, anchor);\\n    return newPt;\\n  }\\n  applySkew(pt, anchor = this.anchor) {\\n    let newPt = new _Vector.Vector2(pt);\\n    newPt = _Vector.Vector2.SUBTRACT(newPt, anchor);\\n    newPt = newPt.skewed(_Vector.Vector2.ZERO, this.skew);\\n    newPt = _Vector.Vector2.ADD(newPt, anchor);\\n    return newPt;\\n  }\\n  applyScale(pt, anchor = this.anchor) {\\n    let newPt = new _Vector.Vector2(pt);\\n    newPt = _Vector.Vector2.SUBTRACT(newPt, anchor);\\n    newPt = _Vector.Vector2.MULTIPLY(newPt, this.scale);\\n    newPt = _Vector.Vector2.ADD(newPt, anchor);\\n    return newPt;\\n  }\\n  applyInverseTransform(pt, anchor = this._anchor, order = ['T', 'R', 'K', 'S']) {\\n    let inv = this.inverted();\\n    return inv.applyTransform(pt, anchor, order.slice().reverse());\\n  }\\n  applyTransform(pt, anchor = this.anchor, order = ['S', 'K', 'R', 'T']) {\\n    let newPt = new _Vector.Vector2(pt);\\n    newPt = _Vector.Vector2.SUBTRACT(newPt, anchor);\\n    for (let trans of order) {\\n      if (!trans) continue;\\n      switch (trans?.toUpperCase()) {\\n        case 'T':\\n        case 'TRANSLATE':\\n        case 'POSITION':\\n          newPt = this.applyTranslate(newPt, _Vector.Vector2.ZERO);\\n          break;\\n        case 'R':\\n        case 'ROTATE':\\n        case 'ROTATION':\\n          newPt = this.applyRotate(newPt, _Vector.Vector2.ZERO);\\n          break;\\n        case 'K':\\n        case 'SKEW':\\n          newPt = this.applySkew(newPt, _Vector.Vector2.ZERO);\\n          break;\\n        case 'S':\\n        case 'SCALE':\\n        case 'SIZE':\\n          newPt = this.applyScale(newPt, _Vector.Vector2.ZERO);\\n          break;\\n        default:\\n          newPt = newPt;\\n          break;\\n      }\\n    }\\n    newPt = _Vector.Vector2.ADD(newPt, anchor);\\n    return newPt;\\n\\n    // let translate = this.position;\\n    // let scale = this.scale;\\n    // let rotate = this.rotation;\\n    // let skew = this.skew;\\n    // let anchor = this.anchor;\\n\\n    // let a = (scale.x) * ( Math.cos(rotate) - (Math.sin(rotate) * Math.tan(skew.x)) );\\n    // let b = (scale.y) * ( Math.sin(rotate) + (Math.cos(rotate) * Math.tan(skew.y)) );\\n    // let c = (scale.x) * ( (Math.cos(rotate) * Math.tan(skew.x)) - Math.sin(rotate) );\\n    // let d = (scale.y) * ( (Math.sin(rotate) * Math.tan(skew.y)) + Math.cos(rotate) );\\n\\n    // let tx = translate.x; let ty = translate.y;\\n\\n    // let ax = anchor.x; let ay = anchor.y;\\n\\n    // let vx = pt.x; let vy = pt.y;\\n\\n    // let Rx = ((a*(vx-ax)) + (c*(vy-ay)) + tx) + ax;\\n    // let Ry = ((b*(vx-ax)) + (d*(vy-ay)) + ty) + ay;\\n\\n    // return new Vector2(Rx,Ry);\\n  }\\n\\n  asMatrix() {\\n    return this.matrix;\\n  }\\n  asArray() {\\n    return [this.a, this.b, this.c, this.d, this.tx, this.ty];\\n  }\\n  asObject() {\\n    return {\\n      position: this.position?.toJSON() || null,\\n      rotation: typeof this.rotation === 'number' ? this.rotation : null,\\n      scale: this.scale?.toJSON() || null,\\n      skew: this.skew?.toJSON() || null,\\n      anchor: this.anchor?.toJSON() || null\\n    };\\n  }\\n  toString() {\\n    return `( Translate: ${this.position} Rotate: (${this.rotation}) Scale: ${this.scale} Skew: ${this.skew} Anchor: ${this.anchor} )`;\\n  }\\n  toJSON() {\\n    return this.asObject();\\n  }\\n}\\nexports.Transform2 = Transform2;\\n\\n//# sourceURL=webpack://VECTOR2/./lib/cjs/src/Transform2/Transform2.js?\");\n\n/***/ }),\n\n/***/ \"./lib/cjs/src/Vector2Line/Vector2Line.js\":\n/*!************************************************!*\\\n  !*** ./lib/cjs/src/Vector2Line/Vector2Line.js ***!\n  \\************************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", ({\\n  value: true\\n}));\\nexports.Vector2Line = void 0;\\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \\\"./node_modules/@catsums/my/lib/umd/index.dev.js\\\"));\\nvar _Vector = __webpack_require__(/*! ../Vector2/Vector2 */ \\\"./lib/cjs/src/Vector2/Vector2.js\\\");\\nfunction _getRequireWildcardCache(nodeInterop) {\\n  if (typeof WeakMap !== \\\"function\\\") return null;\\n  var cacheBabelInterop = new WeakMap();\\n  var cacheNodeInterop = new WeakMap();\\n  return (_getRequireWildcardCache = function (nodeInterop) {\\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\\n  })(nodeInterop);\\n}\\nfunction _interopRequireWildcard(obj, nodeInterop) {\\n  if (!nodeInterop && obj && obj.__esModule) {\\n    return obj;\\n  }\\n  if (obj === null || typeof obj !== \\\"object\\\" && typeof obj !== \\\"function\\\") {\\n    return {\\n      default: obj\\n    };\\n  }\\n  var cache = _getRequireWildcardCache(nodeInterop);\\n  if (cache && cache.has(obj)) {\\n    return cache.get(obj);\\n  }\\n  var newObj = {};\\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\\n  for (var key in obj) {\\n    if (key !== \\\"default\\\" && Object.prototype.hasOwnProperty.call(obj, key)) {\\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\\n      if (desc && (desc.get || desc.set)) {\\n        Object.defineProperty(newObj, key, desc);\\n      } else {\\n        newObj[key] = obj[key];\\n      }\\n    }\\n  }\\n  newObj.default = obj;\\n  if (cache) {\\n    cache.set(obj, newObj);\\n  }\\n  return newObj;\\n}\\nclass Vector2Line {\\n  a;\\n  b;\\n  c;\\n  // f //x intercept\\n  // e //y intercept\\n  // m //gradient\\n\\n  get gradient() {\\n    return MY.safeDivide(-this.a, this.b);\\n  }\\n  get m() {\\n    return this.gradient;\\n  }\\n  get xIntercept() {\\n    return MY.safeDivide(-this.c, this.a);\\n  }\\n  get f() {\\n    return this.xIntercept;\\n  }\\n  get yIntercept() {\\n    return MY.safeDivide(-this.c, this.b);\\n  }\\n  get e() {\\n    return this.yIntercept;\\n  }\\n  constructor(x, y) {\\n    if (x instanceof _Vector.Vector2 && y instanceof _Vector.Vector2 || MY.isObject(x) && MY.isObject(y) || MY.isArray(x) && MY.isArray(y)) {\\n      //make line that passes through these points\\n      let a, b, c;\\n      let v1 = new _Vector.Vector2(x.x || x[0] || 0, x.y || x[1] || 0);\\n      let v2 = new _Vector.Vector2(y.x || y[0] || 0, y.y || y[1] || 0);\\n      let m = _Vector.Vector2.SUBTRACT(v2, v1).gradient();\\n\\n      //y=mx+e\\n      //e = y - mx\\n\\n      let e, f;\\n      if (MY.isInfinity(m)) {\\n        //vertical line\\n        c = -(v1.x || v2.x);\\n        b = 0;\\n        a = 1;\\n      } else if (m == 0) {\\n        //horizontal line\\n        a = 0;\\n        b = -1;\\n        c = v1.y || v2.y;\\n      } else {\\n        e = v1.y - m * v1.x;\\n        f = MY.safeDivide(-e, m);\\n        c = -(f * m);\\n        b = MY.safeDivide(-c, e) || 1;\\n        a = -(b * m);\\n\\n        //\\n      }\\n\\n      //finish and account for vertical and horizontal lines\\n\\n      this.a = a;\\n      this.b = b;\\n      this.c = c;\\n    } else if (MY.isObject(x) && 'a' in x && 'b' in x && 'c' in x) {\\n      //use standard form\\n      let obj = x;\\n      this.a = obj.a;\\n      this.b = obj.b;\\n      this.c = obj.c;\\n    } else if (MY.isObject(x) && ('gradient' in x || 'm' in x) && ('e' in x || 'c' in x || 'yIntercept' in x)) {\\n      //use intercept form\\n      let obj = x;\\n      let a, b, c;\\n      let m = obj.gradient || obj.m || 0;\\n      let e = obj.e || obj.c || obj.yIntercept || 0;\\n      let f;\\n      if ('f' in obj || 'xIntercept' in obj) {\\n        f = obj.f || obj.xIntercept || 0;\\n        c = -(f * m);\\n      } else {\\n        c = 1;\\n        f = MY.safeDivide(-c, m);\\n      }\\n      b = MY.safeDivide(-c, e);\\n      a = -(b * m);\\n      this.a = a;\\n      this.b = b;\\n      this.c = c;\\n    } else if (MY.isObject(x) && ('f' in x || 'x' in x || 'c' in x || 'xIntercept' in x) && ('e' in x || 'y' in x || 'yIntercept' in x)) {\\n      //use intercept form but with actual intercepts\\n      let obj = x;\\n      let a, b, c;\\n      let e = obj.e || obj.c || obj.y || obj.yIntercept || 0;\\n      let f = obj.f || obj.x || obj.xIntercept || 0;\\n      let m = new _Vector.Vector2(0 - e, f - 0).gradient();\\n      c = -(f * m);\\n      b = MY.safeDivide(-c, e);\\n      a = -(b * m);\\n      this.a = a;\\n      this.b = b;\\n      this.c = c;\\n    } else if (MY.isNumber(x) && MY.isNumber(y)) {\\n      //treat as x and y intercepts\\n\\n      let a, b, c;\\n      let e = y;\\n      let f = x;\\n      let m = new _Vector.Vector2(0 - e, f - 0).gradient();\\n      c = -(f * m);\\n      b = MY.safeDivide(-c, e);\\n      a = -(b * m);\\n      this.a = a;\\n      this.b = b;\\n      this.c = c;\\n    }\\n  }\\n  getX(y) {\\n    let x;\\n    if (this.b != 0) {\\n      let m = this.gradient;\\n      let e = this.yIntercept;\\n\\n      //y = mx+e\\n      //x = (y - e)/m\\n\\n      x = MY.safeDivide(y - e, m);\\n    } else {\\n      let c = this.c;\\n      let a = this.a;\\n      x = MY.safeDivide(-c, a);\\n    }\\n    return x;\\n  }\\n  getY(x) {\\n    let y;\\n    if (this.a != 0) {\\n      let m = this.gradient;\\n      let e = this.yIntercept;\\n\\n      //y = mx+e\\n      //x = (y - e)/m\\n\\n      y = m * x + e;\\n    } else {\\n      let c = this.c;\\n      let b = this.b;\\n      y = MY.safeDivide(-c, b);\\n    }\\n    return y;\\n  }\\n  equals(other) {\\n    return this.gradient == other.gradient && this.yIntercept == other.yIntercept && this.xIntercept == other.xIntercept;\\n  }\\n  isHorizontal() {\\n    return this.a === 0;\\n  }\\n  isVertical() {\\n    return this.b === 0;\\n  }\\n  hasPoint(point) {\\n    let v = new _Vector.Vector2(point);\\n\\n    //ax+by+c=0\\n\\n    let res;\\n    if (MY.isInfinity(this.a) && MY.isInfinity(this.b)) {\\n      if (a == b) {\\n        // INF + INF\\n        res = Infinity + this.c;\\n      } else {\\n        // INF - INF\\n        res = 0 + this.c;\\n      }\\n    } else {\\n      let ax = this.a * v.x;\\n      let by = this.b * v.y;\\n      let c = this.c;\\n      res = ax + by + c;\\n      res = Number(res);\\n    }\\n    return res == 0;\\n  }\\n  angle() {\\n    let xInt = this.xIntercept;\\n    let yInt = this.yIntercept;\\n    if (xInt == Infinity) return 0; //or Math.PI\\n    if (xInt == -Infinity) return Math.PI; //or Math.PI\\n    if (yInt == Infinity) return Math.PI / 2;\\n    if (yInt == -Infinity) return -(Math.PI / 2);\\n    let vx = new _Vector.Vector2(xInt, 0);\\n    let vy = new _Vector.Vector2(0, yInt);\\n    return vx.angleToPoint(vy);\\n  }\\n  intersect(other) {\\n    //x = (b1c2-b2c1)/(a1b2-a2b1) = BC/AB\\n    //y = (a2c1-a1c2)/(a1b2-a2b1) = AC/AB\\n\\n    if (other.gradient == this.gradient) {\\n      return null;\\n    }\\n    let a1 = this.a,\\n      a2 = other.a;\\n    let b1 = this.b,\\n      b2 = other.b;\\n    let c1 = this.c,\\n      c2 = other.c;\\n    let b1c2 = b1 * c2;\\n    let b2c1 = b2 * c1;\\n    let a1b2 = a1 * b2;\\n    let a2b1 = a2 * b1;\\n    let a2c1 = a2 * c1;\\n    let a1c2 = a1 * c2;\\n    let BC, AB, AC;\\n    if (MY.isInfinity(b1c2) && MY.isInfinity(b2c1) && b1c2 == b2c1) {\\n      BC = b1c2;\\n    } else {\\n      BC = b1c2 - b2c1;\\n    }\\n    if (MY.isInfinity(a1b2) && MY.isInfinity(a2b1) && a1b2 == a2b1) {\\n      AB = a1b2;\\n    } else {\\n      AB = a1b2 - a2b1;\\n    }\\n    if (MY.isInfinity(a2c1) && MY.isInfinity(a1c2) && a2c1 == a1c2) {\\n      AC = a2c1;\\n    } else {\\n      AC = a2c1 - a1c2;\\n    }\\n\\n    // console.log({BC,AB,AC, l1:this,l2:other})\\n\\n    let x = MY.safeDivide(BC, AB);\\n    let y = MY.safeDivide(AC, AB);\\n\\n    // console.log({x,y})\\n\\n    return new _Vector.Vector2(x, y);\\n  }\\n  perpendicular(point) {\\n    point = new _Vector.Vector2(point);\\n    if (this.a == 0) {\\n      let a = this.b,\\n        b = this.a,\\n        c = point.x;\\n      return new Vector2Line({\\n        a,\\n        b,\\n        c\\n      });\\n    } else if (this.b == 0) {\\n      let a = this.b,\\n        b = this.a,\\n        c = point.y;\\n      return new Vector2Line({\\n        a,\\n        b,\\n        c\\n      });\\n    } else {\\n      let m = MY.safeDivide(-1, this.gradient);\\n      let e = point.y + 1 / m * point.x;\\n      let f = MY.safeDivide(-e, m);\\n      return new Vector2Line({\\n        gradient: m,\\n        xIntercept: f,\\n        yIntercept: f\\n      });\\n    }\\n  }\\n  normal() {\\n    return new _Vector.Vector2(this.a, this.b);\\n  }\\n  mirror(point) {\\n    point = new _Vector.Vector2(point);\\n    if (this.hasPoint(point)) {\\n      return new _Vector.Vector2(point);\\n    }\\n    let _normal = this.normal();\\n    let unitNormal = _normal.normalized();\\n    let unitC = MY.safeDivide(this.c, _normal.length());\\n    let signedDist = unitNormal.x * point.x + unitNormal.y * point.y + unitC;\\n    let mx = point.x - 2 * unitNormal.x * signedDist;\\n    let my = point.y - 2 * unitNormal.y * signedDist;\\n    return new _Vector.Vector2(mx, my);\\n  }\\n  asObject() {\\n    return {\\n      a: this.a,\\n      b: this.b,\\n      c: this.c\\n    };\\n  }\\n  toString() {\\n    return `(${this.a}x + ${this.b}y + ${this.c})`;\\n  }\\n  toJSON() {\\n    return this.asObject();\\n  }\\n}\\nexports.Vector2Line = Vector2Line;\\n\\n//# sourceURL=webpack://VECTOR2/./lib/cjs/src/Vector2Line/Vector2Line.js?\");\n\n/***/ }),\n\n/***/ \"./lib/cjs/src/Vector2/Vector2.js\":\n/*!****************************************!*\\\n  !*** ./lib/cjs/src/Vector2/Vector2.js ***!\n  \\****************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", ({\\n  value: true\\n}));\\nexports.Vector2 = void 0;\\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \\\"./node_modules/@catsums/my/lib/umd/index.dev.js\\\"));\\nfunction _getRequireWildcardCache(nodeInterop) {\\n  if (typeof WeakMap !== \\\"function\\\") return null;\\n  var cacheBabelInterop = new WeakMap();\\n  var cacheNodeInterop = new WeakMap();\\n  return (_getRequireWildcardCache = function (nodeInterop) {\\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\\n  })(nodeInterop);\\n}\\nfunction _interopRequireWildcard(obj, nodeInterop) {\\n  if (!nodeInterop && obj && obj.__esModule) {\\n    return obj;\\n  }\\n  if (obj === null || typeof obj !== \\\"object\\\" && typeof obj !== \\\"function\\\") {\\n    return {\\n      default: obj\\n    };\\n  }\\n  var cache = _getRequireWildcardCache(nodeInterop);\\n  if (cache && cache.has(obj)) {\\n    return cache.get(obj);\\n  }\\n  var newObj = {};\\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\\n  for (var key in obj) {\\n    if (key !== \\\"default\\\" && Object.prototype.hasOwnProperty.call(obj, key)) {\\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\\n      if (desc && (desc.get || desc.set)) {\\n        Object.defineProperty(newObj, key, desc);\\n      } else {\\n        newObj[key] = obj[key];\\n      }\\n    }\\n  }\\n  newObj.default = obj;\\n  if (cache) {\\n    cache.set(obj, newObj);\\n  }\\n  return newObj;\\n}\\nclass Vector2 {\\n  x;\\n  y;\\n  static get ZERO() {\\n    return new Vector2(0, 0);\\n  }\\n  static get ONE() {\\n    return new Vector2(1, 1);\\n  }\\n  static get NEG_ONE() {\\n    return new Vector2(-1, -1);\\n  }\\n  static get INF() {\\n    return new Vector2(Infinity, Infinity);\\n  }\\n  static get NEG_INF() {\\n    return new Vector2(-Infinity, -Infinity);\\n  }\\n  static get EPSILON() {\\n    return new Vector2(Number.MIN_VALUE, Number.MIN_VALUE);\\n  }\\n  static get UP() {\\n    return new Vector2(0, -1);\\n  }\\n  static get DOWN() {\\n    return new Vector2(0, 1);\\n  }\\n  static get LEFT() {\\n    return new Vector2(-1, 0);\\n  }\\n  static get RIGHT() {\\n    return new Vector2(1, 0);\\n  }\\n  static ADD(v1, v2) {\\n    return new Vector2(v1.x + v2.x, v1.y + v2.y);\\n  }\\n  add(other) {\\n    this.x += other.x;\\n    this.y += other.y;\\n  }\\n  static SUBTRACT(v1, v2) {\\n    return new Vector2(v1.x - v2.x, v1.y - v2.y);\\n  }\\n  subtract(other) {\\n    this.x -= other.x;\\n    this.y -= other.y;\\n  }\\n  static MULTIPLY(v1, v2) {\\n    if (MY.isNumber(v2)) v2 = new Vector2(v2, v2);\\n    return new Vector2(v1.x * v2.x, v1.y * v2.y);\\n  }\\n  multiply(other) {\\n    if (MY.isNumber(other)) {\\n      return this.scale(other);\\n    }\\n    this.x *= other.x;\\n    this.y *= other.y;\\n  }\\n  static DIVIDE(v1, v2) {\\n    return new Vector2(v1.x / v2.x, v1.y / v2.y);\\n  }\\n  divide(other) {\\n    this.x /= other.x;\\n    this.y /= other.y;\\n  }\\n  static SCALE(v1, n) {\\n    return new Vector2(v1.x * n, v1.y * n);\\n  }\\n  scaleBy(n) {\\n    this.x *= n;\\n    this.y *= n;\\n  }\\n  scaled(n) {\\n    return new Vector2(this.x * n, this.y * n);\\n  }\\n  static MOD(v1, v2) {\\n    return new Vector2(mod(v1.x, v2.x), mod(v1.y, v2.y));\\n  }\\n  mod(other) {\\n    this.x = mod(this.x, other.x);\\n    this.y = mod(this.y, other.y);\\n  }\\n  static MODBY(v1, n) {\\n    return new Vector2(mod(v1.x, n), mod(v1.y, n));\\n  }\\n  modBy(n) {\\n    this.x = mod(this.x, n);\\n    this.y = mod(this.y, n);\\n  }\\n  static DOT(v1, v2) {\\n    return v1.x * v2.x + v1.y * v2.y;\\n  }\\n  static EQUALS(v1, v2, p = 0) {\\n    if (v1 === v2) return true;\\n    if (!v1 || !v2) return false;\\n    if (v1?.x === v2?.x && v1?.y === v2?.y) return true;\\n    if (MY.roundTo(v1.x, p) === MY.roundTo(v2.x, p) && MY.roundTo(v1.y, p) === MY.roundTo(v2.y, p)) return true;\\n    if (Math.abs(v1?.x - v2?.x) < Number.EPSILON && Math.abs(v1?.y - v2?.y) < Number.EPSILON) return true;\\n    return false;\\n  }\\n  equals(other, precision = 0) {\\n    return Vector2.EQUALS(this, other, precision);\\n  }\\n  static SortAlgo(a, b) {\\n    if (a.isGreaterThan(b)) return 1;else if (a.isLesserThan(b)) return -1;\\n    return 0;\\n  }\\n  static SortAlgoX(a, b) {\\n    if (a.x > b.x) return 1;else if (a.x < b.x) return -1;\\n    return 0;\\n  }\\n  static SortAlgoY(a, b) {\\n    if (a.y > b.y) return 1;else if (a.y < b.y) return -1;\\n    return 0;\\n  }\\n  static SortAlgoXY(a, b) {\\n    if (a.x > b.x) return 1;else if (a.x < b.x) return -1;\\n    if (a.y > b.y) return 1;else if (a.y < b.y) return -1;\\n    return 0;\\n  }\\n  static SortAlgoXY(a, b) {\\n    if (a.y > b.y) return 1;else if (a.y < b.y) return -1;\\n    if (a.x > b.x) return 1;else if (a.x < b.x) return -1;\\n    return 0;\\n  }\\n  static SortAlgoAvg(a, b) {\\n    let x, y;\\n    if (a.x > b.x) x = 1;else if (a.x < b.x) x = -1;else x = 0;\\n    if (a.y > b.y) y = 1;else if (a.y < b.y) y = -1;else y = 0;\\n    let avg = x + y / 2;\\n    return Math.trunc(avg);\\n  }\\n  constructor(x = 0, y = 0) {\\n    if (x instanceof Vector2 || MY.isObject(x) && 'x' in x && 'y' in x) {\\n      this.x = x.x;\\n      this.y = x.y;\\n    } else if (MY.isArray(x) && MY.isNumber(x[0]) && MY.isNumber(x[1])) {\\n      this.x = x[0];\\n      this.y = x[1];\\n    } else if (MY.isNumber(x) && MY.isNumber(y)) {\\n      this.x = x;\\n      this.y = y;\\n    } else {\\n      this.x = 0;\\n      this.y = 0;\\n    }\\n  }\\n  abs() {\\n    var v = new Vector2(Math.abs(this.x), Math.abs(this.y));\\n    return v;\\n  }\\n  lengthSquared() {\\n    var llengthSquared = Math.pow(this.x, 2) + Math.pow(this.y, 2);\\n    return llengthSquared;\\n  }\\n  length() {\\n    return Math.sqrt(this.lengthSquared());\\n  }\\n  lerp(other, t) {\\n    let x = this.x + (other.x - this.x) * t;\\n    let y = this.y + (other.y - this.y) * t;\\n    return new Vector2(x, y);\\n  }\\n  sumOfParts() {\\n    return this.x + this.y;\\n  }\\n  ratioed() {\\n    var sum = this.sumOfParts();\\n    return new Vector2(MY.safeDivide(this.x, sum), MY.safeDivide(this.y, sum));\\n  }\\n  isNormalised() {\\n    return Math.abs(this.lengthSquared() - 1) == 0;\\n  }\\n  normalized() {\\n    var llen = this.length();\\n    return new Vector2(MY.safeDivide(this.x, llen), MY.safeDivide(this.y, llen));\\n  }\\n  normalised() {\\n    return this.normalized();\\n  }\\n  magnitude() {\\n    return this.length();\\n  }\\n  dot(other) {\\n    return this.x * other.x + this.y * other.y;\\n  }\\n  lineTo(other) {\\n    return Vector2.SUBTRACT(other, this);\\n  }\\n  gradient() {\\n    return MY.safeDivide(this.y, this.x);\\n  }\\n  angle() {\\n    // let prod = MY.safeDivide(this.y, this.x);\\n    return Math.atan2(this.y, this.x);\\n  }\\n  angleTo(other) {\\n    return this.angle() - other.angle();\\n  }\\n  angleToPoint(other) {\\n    return this.lineTo(other).angle();\\n  }\\n  angleBetween(a, b) {\\n    //p1 = c, p2 = a, p3 = b\\n    let c = new Vector2(this);\\n    let top = a.y * (c.x - b.x) + c.y * (b.x - a.x) + b.y * (a.x - c.x);\\n    let bot = (a.x - c.x) * (c.x - b.x) + (a.y - c.y) * (c.y - b.y);\\n\\n    // let ratio = MY.safeDivide(top,bot);\\n\\n    let angle = Math.atan2(top, bot);\\n    return angle;\\n  }\\n  distanceSquaredTo(other) {\\n    return Vector2.SUBTRACT(other, this).lengthSquared();\\n  }\\n  distanceTo(other) {\\n    return Vector2.SUBTRACT(other, this).length();\\n  }\\n  directionTo(other) {\\n    return Vector2.SUBTRACT(other, this).normalized();\\n  }\\n  rotateAround(pivot, angle) {\\n    let pt = new Vector2(this);\\n    let ct = new Vector2(pivot);\\n    let sinO = Math.sin(angle);\\n    let cosO = Math.cos(angle);\\n    pt.x -= ct.x;\\n    pt.y -= ct.y;\\n    this.x = pt.x * cosO - pt.y * sinO + ct.x;\\n    this.y = pt.x * sinO + pt.y * cosO + ct.y;\\n  }\\n  rotated(pivot, angle) {\\n    let pt = new Vector2(this);\\n    let ct = new Vector2(pivot);\\n    let sinO = Math.sin(angle);\\n    let cosO = Math.cos(angle);\\n    pt.x -= ct.x;\\n    pt.y -= ct.y;\\n    let _x = pt.x * cosO - pt.y * sinO + ct.x;\\n    let _y = pt.x * sinO + pt.y * cosO + ct.y;\\n    return new Vector2(_x, _y);\\n  }\\n  skewed(pivot, skewer) {\\n    let pt = new Vector2(this);\\n    let ct = new Vector2(pivot);\\n    pt.x -= ct.x;\\n    pt.y -= ct.y;\\n    let _x = pt.x + pt.y * skewer.x + ct.x;\\n    let _y = pt.x * skewer.y + pt.y + ct.y;\\n    return new Vector2(_x, _y);\\n  }\\n  skew(pivot, skewer) {\\n    let pt = new Vector2(this);\\n    let ct = new Vector2(pivot);\\n    pt.x -= ct.x;\\n    pt.y -= ct.y;\\n    this.x = pt.x + pt.y * skewer.x + ct.x;\\n    this.y = pt.x * skewer.y + pt.y + ct.y;\\n  }\\n  static INVERSE(v1) {\\n    return v1.inverse();\\n  }\\n  inverse() {\\n    let ix = MY.safeDivide(1, this.x);\\n    let iy = MY.safeDivide(1, this.y);\\n    return new Vector2(ix, iy);\\n  }\\n  static FLIPPED(v1) {\\n    return new Vector2(v1.y, v1.x);\\n  }\\n  flipped() {\\n    return new Vector2(this.y, this.x);\\n  }\\n  static MIDPOINT(arr) {\\n    if (!MY.isArray(arr)) {\\n      arr = [];\\n    }\\n    let _x = 0,\\n      _y = 0;\\n    for (let v of arr) {\\n      v = new Vector2(v);\\n      _x += v.x;\\n      _y += v.y;\\n    }\\n    let x = MY.safeDivide(_x, arr.length);\\n    let y = MY.safeDivide(_y, arr.length);\\n    return new Vector2(x, y);\\n  }\\n  midPoint(other) {\\n    let arr = [];\\n    if (!MY.isArray(other)) {\\n      arr.push(other);\\n    } else {\\n      arr = arr.concat(other);\\n    }\\n    let _x = 0,\\n      _y = 0;\\n    for (let v of arr) {\\n      v = new Vector2(v);\\n      _x += v.x;\\n      _y += v.y;\\n    }\\n    _x += this.x;\\n    _y += this.y;\\n    let x = MY.safeDivide(_x, arr.length + 1);\\n    let y = MY.safeDivide(_y, arr.length + 1);\\n    return new Vector2(x, y);\\n  }\\n  floor() {\\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\\n  }\\n  ceil() {\\n    return new Vector2(Math.ceil(this.x), Math.ceil(this.y));\\n  }\\n  reflect(other) {\\n    return Vector2.SUBTRACT(this, Vector2.SCALE(other, 2 * Vector2.DOT(this, other)));\\n  }\\n  project(norm) {\\n    return Vector2.SCALE(norm, this.dot(norm) / norm.lengthSquared());\\n  }\\n  slide(other) {\\n    return Vector2.SUBTRACT(this, Vector2.SCALE(other, this.dot(other)));\\n  }\\n  bounce(other) {\\n    return Vector2.NEG(this.reflect(other));\\n  }\\n  closestPoint(arr, exclusive = false) {\\n    if (!MY.isArray(arr) || !arr.length) return null;\\n    let pt = null;\\n    let dist = Infinity;\\n    for (let v of arr) {\\n      if (exclusive && v.equals(this)) {\\n        continue;\\n      }\\n      let _dist = Math.abs(v.distanceTo(this));\\n      if (_dist < dist) {\\n        pt = v;\\n        dist = _dist;\\n      }\\n    }\\n    return pt;\\n  }\\n  sortPointsByClosest(points) {\\n    if (!MY.isArray(points)) return null;\\n    let arr = points.slice();\\n    let len = arr.length;\\n    let newArr = [];\\n    // console.log({arr,len,points,newArr})\\n    for (let i = 0; i < len; i++) {\\n      let pt = this.closestPoint(arr);\\n      // console.log({pt})\\n      if (!pt) continue;\\n      newArr.push(pt);\\n      let index = arr.indexOf(pt);\\n      arr.splice(index, 1);\\n      // MY.arrayRemove(arr, pt);\\n      i--;\\n    }\\n    return newArr;\\n  }\\n  toString() {\\n    let out = \\\"( \\\" + String(this.x) + \\\" , \\\" + String(this.y) + \\\" )\\\";\\n    return out;\\n  }\\n  asObject() {\\n    return {\\n      x: this.x,\\n      y: this.y\\n    };\\n  }\\n  asArray() {\\n    return [this.x, this.y];\\n  }\\n  toJSON() {\\n    return this.asObject();\\n  }\\n  isGreaterThan(other) {\\n    return this.lengthSquared() > other.lengthSquared();\\n  }\\n  isLesserThan(other) {\\n    return this.lengthSquared() < other.lengthSquared();\\n  }\\n  static NEG(v1) {\\n    return new Vector2(-v1.x, -v1.y);\\n  }\\n  neg() {\\n    return Vector2.NEG(this);\\n  }\\n  static quadraticBezier(points, t) {\\n    let qPoints = [];\\n    for (let i = 0; i < points.length - 1; i++) {\\n      let pA = new Vector2(points[i]);\\n      let pB = new Vector2(points[i + 1]);\\n      let pt = pA.lerp(pB, t);\\n      qPoints.push(pt);\\n    }\\n    if (qPoints.length < 2) {\\n      return qPoints[0];\\n    }\\n    return Vector2.quadraticBezier(qPoints, t);\\n  }\\n  static quadraticBezierPoints(points, inc) {\\n    let qPoints = [];\\n    if (MY.isArray(points) && MY.isNumber(inc) && inc > 0) {\\n      let t = 0;\\n      let last = false;\\n      while (t <= 1) {\\n        qPoints.push(Vector2.quadraticBezier(points, t));\\n        t += inc;\\n        if (t > 1 && !last) {\\n          t = 1;\\n          last = true;\\n        }\\n      }\\n    }\\n    return qPoints;\\n  }\\n  static getSVGAngle(u, v) {\\n    u = new Vector2(u);\\n    v = new Vector2(v);\\n    let dot = Vector2.DOT(u, v);\\n    let len = u.length() * v.length();\\n    var clamp = function (n, min, max) {\\n      max = Math.max(min, max);\\n      min = Math.min(min, max);\\n      return Math.min(Math.max(n, min), max);\\n    };\\n    let ang = Math.acos(clamp(dot / len, -1, 1));\\n    if (u.x * v.y - u.y * v.x < 0) {\\n      ang = -ang;\\n    }\\n    return ang;\\n  }\\n}\\nexports.Vector2 = Vector2;\\n\\n//# sourceURL=webpack://VECTOR2/./lib/cjs/src/Vector2/Vector2.js?\");\n\n/***/ }),\n\n/***/ \"./lib/cjs/src/index.js\":\n/*!******************************!*\\\n  !*** ./lib/cjs/src/index.js ***!\n  \\******************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar _Vector = __webpack_require__(/*! ./Vector2/Vector2 */ \\\"./lib/cjs/src/Vector2/Vector2.js\\\");\\nvar _Vector2Line = __webpack_require__(/*! ./Vector2Line/Vector2Line */ \\\"./lib/cjs/src/Vector2Line/Vector2Line.js\\\");\\nvar _Rect = __webpack_require__(/*! ./Rect2/Rect2 */ \\\"./lib/cjs/src/Rect2/Rect2.js\\\");\\nvar _Transform = __webpack_require__(/*! ./Transform2/Transform2 */ \\\"./lib/cjs/src/Transform2/Transform2.js\\\");\\nmodule.exports = {\\n  Vector2: _Vector.Vector2,\\n  Vector2Line: _Vector2Line.Vector2Line,\\n  Rect2: _Rect.Rect2,\\n  Transform2: _Transform.Transform2\\n};\\n\\n//# sourceURL=webpack://VECTOR2/./lib/cjs/src/index.js?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_78832__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_78832__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can't be inlined because the eval devtool is used.\n/******/ \tvar __webpack_exports__ = __nested_webpack_require_78832__(\"./lib/cjs/index.js\");\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n\n//# sourceURL=webpack://TargetObservers/./node_modules/@catsums/vector2/lib/umd/index.dev.js?");

/***/ }),

/***/ "./lib/cjs/index.js":
/*!**************************!*\
  !*** ./lib/cjs/index.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./src */ \"./lib/cjs/src/index.js\");\n\n//# sourceURL=webpack://TargetObservers/./lib/cjs/index.js?");

/***/ }),

/***/ "./lib/cjs/src/index.js":
/*!******************************!*\
  !*** ./lib/cjs/src/index.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ProcessingTarget = __webpack_require__(/*! ./src/ProcessingTarget */ \"./lib/cjs/src/src/ProcessingTarget.js\");\nvar _TransformObserver = __webpack_require__(/*! ./src/TransformObserver */ \"./lib/cjs/src/src/TransformObserver.js\");\nvar ElementFunctions = _interopRequireWildcard(__webpack_require__(/*! ./src/ElementFunctions */ \"./lib/cjs/src/src/ElementFunctions.js\"));\nvar _CollisionObserver = __webpack_require__(/*! ./src/CollisionObserver */ \"./lib/cjs/src/src/CollisionObserver.js\");\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nmodule.exports = {\n  ProcessingTarget: _ProcessingTarget.ProcessingTarget,\n  TransformObserver: _TransformObserver.TransformObserver,\n  ElementFunctions,\n  CollisionObserver: _CollisionObserver.CollisionObserver,\n  CollisionType: _CollisionObserver.CollisionType\n};\n\n//# sourceURL=webpack://TargetObservers/./lib/cjs/src/index.js?");

/***/ }),

/***/ "./lib/cjs/src/src/CollisionObserver.js":
/*!**********************************************!*\
  !*** ./lib/cjs/src/src/CollisionObserver.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CollisionType = exports.CollisionObserver = void 0;\nvar _vector = __webpack_require__(/*! @catsums/vector2 */ \"./node_modules/@catsums/vector2/lib/umd/index.dev.js\");\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \"./node_modules/@catsums/my/lib/umd/index.dev.js\"));\nvar _ProcessingTarget = __webpack_require__(/*! ./ProcessingTarget */ \"./lib/cjs/src/src/ProcessingTarget.js\");\nvar EF = _interopRequireWildcard(__webpack_require__(/*! ./ElementFunctions */ \"./lib/cjs/src/src/ElementFunctions.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n///CollisionObserver.js\n\n// import SVGPathParser from 'svg-path-parser';\n// import PolygonClipping from 'polygon-clipping';\n\nObject.entries(EF).forEach(([name, exported]) => window[name] = exported);\n\n/* \r\nlet proxy = {\r\n\tid: String(ConnectId)\r\n\tcollisionLayers: Array(String),\r\n\ttargetLayers: Array(String),\r\n\ttolerance: Number\r\n\tcurrentColls: Array(String(ConnectId))\r\n}\r\n */\n\nlet defaultObserveOpts = {\n  rects: {\n    boundingrect: false,\n    offsetrect: false,\n    transformrect: false,\n    clippath: false,\n    shapeoutside: false\n    // svgshape: false,\n  },\n\n  collisionLayers: [],\n  targetLayers: [],\n  targets: [],\n  tolerance: 0.001\n};\nconst CollisionType = {\n  IN: 1,\n  OUT: -1,\n  CHANGE: 0\n};\nexports.CollisionType = CollisionType;\nclass CollisionObserver extends _ProcessingTarget.ProcessingTarget {\n  targetName = MY.randomID('[CollisionObserver:', ']');\n  _precision = 0.001;\n  _tolerance = 0.001;\n  _observedElements = {}; // {String(connectID):Element}\n  _proxies = new Map(); // {String(connectID):ProxyObject} or Map({Element:ProxyObject})\n\n  _collisionLayers = {}; // {String:String[connectID]}\n\n  _entriesQueue = [];\n  _callback = (entries, obs) => {};\n  constructor(callback = this._callback, opts = {}) {\n    super(opts);\n    this._precision = opts?.precision || this._precision;\n    this._tolerance = opts?.tolerance || this._tolerance;\n    if (MY.isFunction(callback)) {\n      this._callback = callback;\n    }\n  }\n  onPhysicsProcess(delta) {\n    this.checkUpdates(Object.values(this._observedElements));\n  }\n  async checkUpdates(elements) {\n    let entries = [];\n    let promises = [];\n    for (let elem of elements) {\n      promises.push(this.checkUpdate(elem));\n    }\n    let results = await Promise.all(promises);\n    for (let res of results) {\n      if (res && MY.isObject(res)) {\n        entries.push(res);\n      }\n    }\n    if (entries.length) {\n      try {\n        this.handleEntries(entries);\n      } catch (err) {\n        console.log(err);\n        return;\n      }\n    }\n  }\n  async checkUpdate(elem) {\n    if (!elem) return null;\n    let processTime = this.elapsedFixedTime;\n    let proxy = this._proxies.get(elem);\n    if (!proxy) return null;\n    let entry = {\n      id: proxy.id,\n      target: elem,\n      collisions: []\n      // {target:Elem, type:CollisionType, layers:[String], intersect:Rect2, intersectPoints:[{x,y}]}\n    };\n\n    let targetLayers = proxy.collision.targetLayers;\n    for (let _layer of targetLayers) {\n      let collLayer = this._collisionLayers[_layer];\n\n      // MY.clog({collLayer, _layer})\n\n      if (!collLayer) continue;\n      for (let targID of collLayer) {\n        let targElem = this._observedElements[targID];\n        if (!targElem) continue;\n        let targProxy = this._proxies.get(targElem);\n        if (!targProxy) continue;\n        let _collisionData = {};\n\n        // MY.clog({targID, targElem, targProxy, rects:proxy.rects})\n\n        for (let opt of Object.keys(proxy.rects)) {\n          if (!proxy.rects[opt]) continue;\n          let existingCollData = entry.collisions.find(collData => collData.target == targElem && collData.rect == opt);\n          if (existingCollData) {\n            existingCollData.layers.push(_layer);\n            continue;\n          }\n\n          // MY.clog({opt,existingCollData})\n\n          switch (opt) {\n            case 'boundingrect':\n              {\n                let currRect = EF.getGlobalBoundingRect(elem);\n                let targRect = EF.getGlobalBoundingRect(targElem);\n                let _intersect = currRect.getIntersectWith(targRect, this._tolerance);\n                // MY.clog({currRect, targRect, _intersect, opt})\n                if (_intersect && !proxy.currentCollisions.find(_c => _c.id == targID)) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.IN,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = _intersect.toJSON();\n                } else if (!_intersect && proxy.currentCollisions.find(_c => _c.id == targID)) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.OUT,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = null;\n                } else if (_intersect && !EF.compareJSON(_intersect, proxy.currentCollisions.find(_c => _c.id == targID))) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.CHANGE,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = _intersect.toJSON();\n                }\n              }\n              break;\n            case 'offsetrect':\n              {\n                let currRect = EF.getGlobalOffsetRect(elem);\n                let targRect = EF.getGlobalOffsetRect(targElem);\n                let _intersect = currRect.getIntersectWith(targRect, this._tolerance);\n                if (_intersect && !proxy.currentCollisions.find(_c => _c.id == targID)) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.IN,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = _intersect.toJSON();\n                } else if (!_intersect && proxy.currentCollisions.find(_c => _c.id == targID)) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.OUT,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = null;\n                } else if (_intersect && !EF.compareJSON(_intersect, proxy.currentCollisions.find(_c => _c.id == targID))) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.CHANGE,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = _intersect.toJSON();\n                }\n              }\n              break;\n            case 'transformrect':\n              {\n                let currRect = EF.getGlobalOffsetRect(elem);\n                let targRect = EF.getGlobalOffsetRect(targElem);\n                let elemT0 = EF.getElemTransformFromCSSStyle(elem, this._tolerance);\n                let elemT1 = EF.getElemTransformFromMatrix(elem, this._tolerance);\n                let targT0 = EF.getElemTransformFromCSSStyle(targElem, this._tolerance);\n                let targT1 = EF.getElemTransformFromMatrix(targElem, this._tolerance);\n                let elemPts = currRect.getCorners().map(pt => {\n                  return elemT1.applyTransform(pt, anchor);\n                }).map(pt => {\n                  return elemT0.applyTransform(pt, anchor);\n                });\n                let targPts = targRect.getCorners().map(pt => {\n                  return targT1.applyTransform(pt, anchor);\n                }).map(pt => {\n                  return targT0.applyTransform(pt, anchor);\n                });\n                let _intersects = EF.getPolygonIntersect(elemPts, targPts, this._precision);\n                if (_intersects && !proxy.currentCollisions.find(_c => _c.id == targID)) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.IN,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = _intersects.map(v => v.toJSON?.() ?? v);\n                } else if (!_intersects && proxy.currentCollisions.find(_c => _c.id == targID)) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.OUT,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = null;\n                } else if (_intersects && !EF.compareJSON(_intersect, proxy.currentCollisions.find(_c => _c.id == targID))) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.CHANGE,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = _intersects.map(v => v.toJSON?.() ?? v);\n                }\n              }\n              break;\n            case 'shapeoutside':\n            case 'clippath':\n              {\n                let sOpt = 'clippath';\n                if (opt == 'clippath') sOpt = 'clip-path';\n                if (opt == 'shapeoutside') sOpt = 'shape-outside';\n\n                //check polygon\n                let elemClipPath = window.getComputedStyle(elem)[sOpt];\n                let targClipPath = window.getComputedStyle(targElem)[sOpt];\n                let [elemClipPathShape, elemClipPathProps] = EF.getBasicShapeProps(elemClipPath);\n                let [targClipPathShape, targClipPathProps] = EF.getBasicShapeProps(targClipPath);\n                let elemPts = EF.getElemPointsBasedOnBasicShape(elem, elemClipPathShape, elemClipPathProps, {}, {\n                  vertices: 8,\n                  increment: 0.125\n                });\n                let targPts = EF.getElemPointsBasedOnBasicShape(targElem, targClipPathShape, targClipPathProps, {}, {\n                  vertices: 8,\n                  increment: 0.125\n                });\n                let _intersects = EF.getPolygonIntersect(elemPts, targPts, this._precision);\n                if (_intersects && !proxy.currentCollisions.find(_c => _c.id == targID)) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.IN,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = _intersects.map(v => v.toJSON?.() ?? v);\n                } else if (!_intersects && proxy.currentCollisions.find(_c => _c.id == targID)) {\n                  _collisionData = {\n                    targetID: targID,\n                    target: targElem,\n                    rect: opt,\n                    type: CollisionType.OUT,\n                    layers: [_layer]\n                  };\n                  _collisionData.intersect = null;\n                } else if (_intersects) {\n                  let _x = proxy.currentCollisions.find(_c => _c.id == targID);\n                  if (!EF.compareJSON(_intersects, _x?.intersect)) {\n                    _collisionData = {\n                      targetID: targID,\n                      target: targElem,\n                      rect: opt,\n                      type: CollisionType.CHANGE,\n                      layers: [_layer]\n                    };\n                    _collisionData.intersect = _intersects.map(v => v.toJSON?.() ?? v);\n                  }\n                }\n              }\n              break;\n            default:\n              break;\n          }\n        }\n        if (Object.keys(_collisionData).length) {\n          entry.collisions.push(_collisionData);\n        }\n      }\n    }\n    this.processEntry(elem, entry, {\n      processTime: processTime,\n      logTime: new Date()\n    });\n\n    // MY.clog({entry})\n\n    if (entry.collisions.length) {\n      return entry;\n    }\n    return null;\n  }\n  handleEntries(ents) {\n    this._callback(ents, this);\n    let obs = this;\n    ents.forEach(ent => {\n      ent.collisions.forEach(collData => {\n        if (!collData) return;\n        switch (collData.type) {\n          case CollisionType.IN:\n            {\n              obs.emitSignal('collisionIn', {\n                collisionData: collData\n              }, [ent.target]);\n            }\n            break;\n          case CollisionType.OUT:\n            {\n              obs.emitSignal('collisionOut', {\n                collisionData: collData\n              }, [ent.target]);\n            }\n            break;\n          case CollisionType.CHANGE:\n            {\n              obs.emitSignal('collisionChange', {\n                collisionData: collData\n              }, [ent.target]);\n            }\n            break;\n        }\n        obs.emitSignal('collision', {\n          collisionData: collData\n        }, [ent.target]);\n      });\n    });\n  }\n  processEntry(elem, entry, process) {\n    let proxy = this._proxies.get(elem);\n    if (!proxy) return;\n    if (entry) {\n      for (let collData of entry.collisions) {\n        let targID = collData.targetID;\n        if (collData.type == CollisionType.IN) {\n          proxy.currentCollisions.push({\n            id: targID,\n            intersect: collData.intersect,\n            rect: collData.rect\n          });\n        } else if (collData.type == CollisionType.OUT) {\n          let _coll = proxy.currentCollisions.find(_c => _c.id == targID);\n          let ind = proxy.currentCollisions.indexOf(_coll);\n          proxy.currentCollisions.splice(ind, 1);\n        } else if (collData.type == CollisionType.CHANGE) {\n          let _coll = proxy.currentCollisions.find(_c => _c.id == targID);\n          Object.assign(_coll, {\n            id: targID,\n            intersect: collData.intersect,\n            rect: collData.rect\n          });\n        }\n      }\n      entry.process = {\n        processTime: process.processTime,\n        logTime: process.logTime,\n        timeTaken: process.processTime - proxy._process.processTime\n      };\n    }\n    proxy._process.processTime = process.processTime;\n    proxy._process.logTime = process.logTime;\n  }\n  observe(elem, opts = defaultObserveOpts) {\n    let proxies = null;\n    if (!MY.isObject(opts)) opts = defaultObserveOpts;\n    if (MY.isArray(elem)) {\n      proxies = [];\n      let arr = elem;\n      for (let _elem of arr) {\n        let p = this.observe(_elem, opts);\n        if (p) proxies.push(p);\n      }\n    } else if (elem instanceof Element) {\n      let obsOpts = Object.assign({}, defaultObserveOpts);\n\n      //rects\n      if (MY.isArray(opts.rects)) {\n        for (let r of opts.rects) {\n          r = r.toLowerCase();\n          if (!(r in obsOpts.rects)) continue;\n          obsOpts.rects[r] = true;\n        }\n      } else if (MY.isObject(opts.rects)) {\n        for (let r of Object.keys(opts.rects)) {\n          r = r.toLowerCase();\n          if (!(r in obsOpts.rects)) continue;\n          obsOpts.rects[r] = opts.rects[r] ? true : false;\n        }\n      }\n\n      //collisionlayers and collisionTargets\n      if (MY.isArray(opts.targets)) {\n        obsOpts.targets = opts.targets.filter(_targ => _targ instanceof Element);\n      }\n      if (MY.isArray(opts.collisionLayers)) {\n        obsOpts.collisionLayers = opts.collisionLayers.map(_layer => `${_layer}`);\n      }\n      if (MY.isArray(opts.targetLayers)) {\n        obsOpts.targetLayers = opts.targetLayers.map(_layer => `${_layer}`);\n      }\n      if (MY.isNumber(opts.tolerance)) {\n        obsOpts.tolerance = opts.tolerance;\n      }\n      this.connectElement(elem);\n      let proxy = {\n        id: elem.dataset?.connectId || elem.connectId,\n        _process: {\n          processTime: this.elapsedFixedTime,\n          logTime: new Date()\n        },\n        currentCollisions: [],\n        rects: {},\n        tolerance: 0,\n        collision: {}\n      };\n      this._observedElements[proxy.id] = elem;\n      for (let k of Object.keys(obsOpts.rects)) {\n        if (obsOpts.rects[k] == false) {\n          delete obsOpts.rects[k];\n        } else {\n          k = k.toLowerCase();\n          proxy.rects[k] = obsOpts.rects[k] ? true : false;\n        }\n      }\n      for (let _layer of obsOpts.collisionLayers) {\n        if (!(_layer in this._collisionLayers)) {\n          this._collisionLayers[_layer] = [];\n        }\n        this._collisionLayers[_layer].push(proxy.id);\n      }\n      proxy.collision = {\n        layers: obsOpts.collisionLayers,\n        targets: obsOpts.targets,\n        targetLayers: obsOpts.targetLayers\n      };\n      proxy.tolerance = obsOpts.tolerance;\n      this._proxies.set(elem, proxy);\n      proxies = proxy;\n    }\n    return proxies;\n  }\n  disconnect(elem) {\n    let proxy = this._proxies.get(elem);\n    if (!proxy) return;\n    delete this._observedElements[proxy.id];\n    this.disconnectElement(elem);\n    this._proxies.delete(elem);\n    for (let _layer of proxy.collision?.layers) {\n      if (!this._collisionLayers[_layer]) continue;\n      let ind = this._collisionLayers[_layer].indexOf(elem);\n      if (ind >= 0) {\n        this._collisionLayers[_layer].splice(ind, 1);\n      }\n    }\n  }\n}\nexports.CollisionObserver = CollisionObserver;\n\n//# sourceURL=webpack://TargetObservers/./lib/cjs/src/src/CollisionObserver.js?");

/***/ }),

/***/ "./lib/cjs/src/src/ElementFunctions.js":
/*!*********************************************!*\
  !*** ./lib/cjs/src/src/ElementFunctions.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.compareJSON = compareJSON;\nexports.decomposeMatrix = decomposeMatrix;\nexports.deltaTransformPoint = deltaTransformPoint;\nexports.getAnchor = getAnchor;\nexports.getBasicShapeProps = getBasicShapeProps;\nexports.getElemExpandedTransformFromCSSStyle = getElemExpandedTransformFromCSSStyle;\nexports.getElemExpandedTransformFromMatrix = getElemExpandedTransformFromMatrix;\nexports.getElemPointsBasedOnBasicShape = getElemPointsBasedOnBasicShape;\nexports.getElemTransformFromCSSStyle = getElemTransformFromCSSStyle;\nexports.getElemTransformFromMatrix = getElemTransformFromMatrix;\nexports.getGlobalBoundingRect = getGlobalBoundingRect;\nexports.getGlobalOffsetRect = getGlobalOffsetRect;\nexports.getLocalBoundingRect = getLocalBoundingRect;\nexports.getLocalOffsetRect = getLocalOffsetRect;\nexports.getPointsEllipse = getPointsEllipse;\nexports.getPointsInset = getPointsInset;\nexports.getPointsPath = getPointsPath;\nexports.getPointsPolygon = getPointsPolygon;\nexports.getPolygonIntersect = getPolygonIntersect;\nexports.isPointInsidePolygon = isPointInsidePolygon;\nexports.parseCSSTransform = parseCSSTransform;\nexports.roundTo = roundTo;\nexports.transformCSSCoord = transformCSSCoord;\nvar _vector = __webpack_require__(/*! @catsums/vector2 */ \"./node_modules/@catsums/vector2/lib/umd/index.dev.js\");\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \"./node_modules/@catsums/my/lib/umd/index.dev.js\"));\nvar _svgPathParser = _interopRequireDefault(__webpack_require__(/*! svg-path-parser */ \"./node_modules/svg-path-parser/index.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n// import * as Geometric from 'geometric';\n// import * as PolygonClipping from 'polygon-clipping';\n\nfunction compareJSON(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\nfunction getAnchor(elem, opts = {\n  global: false\n}) {\n  let {\n    global\n  } = opts;\n  let rect = getLocalOffsetRect(elem);\n  if (global) {\n    rect = getGlobalOffsetRect(elem);\n  }\n  let compStyle = window.getComputedStyle(elem);\n  let tOrigin = compStyle[\"transform-origin\"].split(\" \");\n  let extents = rect.extents;\n  let offset = new _vector.Vector2(extents);\n  for (let i = 0; i < tOrigin.length; i++) {\n    let val;\n    if (!tOrigin[i]) continue;\n    switch (tOrigin[i].toLowerCase()) {\n      case 'top':\n        offset.y = extents.y * 0;\n        break;\n      case 'bottom':\n        offset.y = extents.y * 2;\n        break;\n      case 'left':\n        offset.x = extents.y * 0;\n        break;\n      case 'right':\n        offset.x = extents.y * 2;\n        break;\n      case 'center':\n        if (i == 0) offset.x = extents.x;\n        if (i == 1) offset.y = extents.y;\n        break;\n      default:\n        if (tOrigin[i].endsWith(\"%\")) {\n          val = parseFloat(tOrigin[i]) / 100;\n        } else {\n          val = MY.getCSSValueInPixels(tOrigin[i]);\n        }\n        if (i == 0) offset.x = val;\n        if (i == 1) offset.y = val;\n        break;\n    }\n  }\n  let anchor = _vector.Vector2.ADD(rect.start, offset);\n  return anchor;\n}\nfunction getGlobalOffsetRect(elem) {\n  let localRect = getLocalOffsetRect(elem);\n  let globalRect = new _vector.Rect2(localRect);\n  let parent = elem.parentNode || null;\n  if (parent && parent != document.body && parent != document.documentElement) {\n    let parentRect = getLocalOffsetRect(parent);\n    globalRect.position = _vector.Vector2.ADD(parentRect.position, globalRect.position);\n  }\n  return globalRect;\n}\nfunction getLocalOffsetRect(elem) {\n  let localRect;\n  if (elem instanceof HTMLElement) {\n    localRect = new _vector.Rect2(elem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight);\n  } else if (elem instanceof SVGGraphicsElement) {\n    let bbox = elem.getBBox();\n    localRect = new _vector.Rect2(bbox.x, bbox.y, bbox.width, bbox.height);\n  } else {\n    localRect = getLocalBoundingRect(elem);\n  }\n  return localRect;\n}\nfunction getGlobalBoundingRect(elem) {\n  let _rect = elem.getBoundingClientRect();\n  let globalRect = new _vector.Rect2(_rect.x, _rect.y, _rect.width, _rect.height);\n  return globalRect;\n}\nfunction getLocalBoundingRect(elem) {\n  let globalRect = getGlobalBoundingRect(elem);\n  let compStyle = window.getComputedStyle(elem);\n  let positionType = compStyle.position?.toLowerCase();\n  let parentRect = new _vector.Rect2(_vector.Vector2.ZERO, _vector.Vector2.ZERO);\n  switch (positionType) {\n    case 'static':\n    case 'relative':\n    case 'absolute':\n    case 'sticky':\n      {\n        let parent = elem.parentNode || null;\n        if (positionType == 'absolute') {\n          while (parent && parent != elem && parent != document.body && parent != document.documentElement) {\n            let parentPosType = window.getComputedStyle(parent)?.position?.toLowerCase();\n            if (parentPosType == \"static\") {\n              parent = parent.parentNode || null;\n            } else {\n              break;\n            }\n          }\n        }\n        if (parent) {\n          let prect = parent.getBoundingClientRect();\n          parentRect = new _vector.Rect2(prect.x, prect.y, prect.width, prect.height);\n        }\n      }\n      break;\n    case 'fixed':\n      {\n        let parent = elem.parentNode || null;\n        if (parent) {\n          let prect = document.body?.getBoundingClientRect() || document.documentElement?.getBoundingClientRect() || null;\n          parentRect = new _vector.Rect2(prect.x, prect.y, prect.width, prect.height);\n        }\n      }\n      break;\n    default:\n      break;\n  }\n  let localRect = new _vector.Rect2(_vector.Vector2.SUBTRACT(globalRect.position, parentRect.position), globalRect.size);\n  return localRect;\n}\nfunction roundTo(num, step) {\n  if (step == 0) return num;\n  if (MY.isInfinity(step)) return Infinity;\n  let invStep = Math.pow(step, -1);\n  let invMiniStep = Math.pow(step / 10, -1);\n  let initNum = Math.round(num * invMiniStep) / invMiniStep;\n  let init = Math.round(initNum * invStep) / invStep;\n  // let res = init;\n  let res = Math.round((init + Number.EPSILON) * invStep) / invStep;\n  return res;\n}\n\n///https://stackoverflow.com/a/16372587\nfunction deltaTransformPoint(matrix, point) {\n  var dx = point.x * matrix[0] + point.y * matrix[2] + 0;\n  var dy = point.x * matrix[1] + point.y * matrix[3] + 0;\n  return {\n    x: dx,\n    y: dy\n  };\n}\nfunction decomposeMatrix(matrix, _t = 0) {\n  // @see https://gist.github.com/2052247\n\n  if (!MY.isArray(matrix) || matrix.length !== 6) {\n    matrix = [1, 0, 0, 1, 0, 0];\n  }\n\n  // calculate delta transform point\n  var px = deltaTransformPoint(matrix, {\n    x: 0,\n    y: 1\n  });\n  var py = deltaTransformPoint(matrix, {\n    x: 1,\n    y: 0\n  });\n\n  //code to convert css transform into a matrix   \n\n  let [a, b, c, d, tx, ty] = matrix;\n  let det = a * d - c * b;\n  let sx = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  let sy = det / sx;\n  let r = Math.atan2(b, a);\n  let kx = Math.tan(Math.atan2(a * c + b * d, a * a + b * b));\n  let ky = Math.tan(0);\n  return {\n    translate: new _vector.Vector2(roundTo(tx, _t), roundTo(ty, _t)),\n    scale: new _vector.Vector2(roundTo(sx, _t), roundTo(sy, _t)),\n    skew: new _vector.Vector2(roundTo(kx, _t), roundTo(ky, _t)),\n    rotation: roundTo(r, _t / 10) // rotation is the same as skew x\n    // rotation: (Math.atan2(matrix[]))\n  };\n}\n\n///https://stackoverflow.com/a/35543016\nfunction parseCSSTransform(transform) {\n  //add sanity check\n  return transform.split(/\\(|,|\\)/).slice(1, -1).map(function (v) {\n    return parseFloat(v);\n  });\n}\nfunction transformCSSCoord(transformArr, v) {\n  v = new _vector.Vector2(v);\n  let x = v.x,\n    y = v.y;\n  //add sanity checks and default values\t  \n  if (transformArr.length == 6) {\n    //2D matrix //need some math to apply inverse of matrix\n    var t = transformArr,\n      det = t[0] * t[3] - t[1] * t[2];\n    return new _vector.Vector2({\n      x: MY.safeDivide(x * t[3] - y * t[2] + t[2] * t[5] - t[4] * t[3], det),\n      y: MY.safeDivide(-x * t[1] + y * t[0] + t[4] * t[1] - t[0] * t[5], det)\n    });\n  } else {\n    return v;\n  }\n}\nfunction getElemExpandedTransformFromMatrix(elem, _t = 0) {\n  let localTransform = getElemTransformFromMatrix(elem, _t);\n  if (elem != document.body && elem != document.documentElement) {\n    let parent = elem.parentNode || null;\n    if (parent && parent != elem) {\n      let parentTransform = getElemExpandedTransformFromMatrix(parent, _t);\n      parentTransform.addChild(localTransform);\n    }\n  }\n  return localTransform;\n}\nfunction getElemExpandedTransformFromCSSStyle(elem, _t = 0) {\n  let localTransform = getElemTransformFromCSSStyle(elem, _t);\n  if (elem != document.body && elem != document.documentElement) {\n    let parent = elem.parentNode || null;\n    if (parent && parent != elem) {\n      let parentTransform = getElemExpandedTransformFromCSSStyle(parent, _t);\n      parentTransform.addChild(localTransform);\n    }\n  }\n  return localTransform;\n}\nfunction getElemTransformFromCSSStyle(elem, _t = 0) {\n  let compStyle = window.getComputedStyle(elem);\n  let rect = getLocalOffsetRect(elem);\n  let anchor = getAnchor(elem);\n  let p, s, r;\n  let cssTranslate = compStyle.translate.trim().split(' ');\n  if (cssTranslate.length == 1) {\n    let _x = parseFloat(compStyle.translate.split(' ')[0]);\n    if (isNaN(_x)) _x = 0;\n    p = new _vector.Vector2(_x, 0);\n  } else {\n    let _x = parseFloat(compStyle.translate.split(' ')[0]);\n    let _y = parseFloat(compStyle.translate.split(' ')[1]);\n    if (isNaN(_x)) _x = 0;\n    if (isNaN(_y)) _y = 0;\n    p = new _vector.Vector2(_x, _y);\n  }\n  let cssRotate = compStyle.rotate.trim().split(' ');\n  if (cssRotate.length == 1) {\n    let _r = parseFloat(compStyle.rotate.split(' ')[0]);\n    if (isNaN(_r)) _r = 0;\n    r = MY.deg2rad(_r);\n  } else {\n    r = 0;\n  }\n  let cssScale = compStyle.scale.trim().split(' ');\n  if (cssScale.length == 1) {\n    let _x = parseFloat(compStyle.scale.split(' ')[0]);\n    if (isNaN(_x)) _x = 1;\n    s = new _vector.Vector2(_x, _x);\n  } else {\n    let _x = parseFloat(compStyle.scale.split(' ')[0]);\n    let _y = parseFloat(compStyle.scale.split(' ')[1]);\n    if (isNaN(_x)) _x = 0;\n    if (isNaN(_y)) _y = 0;\n    s = new _vector.Vector2(_x, _y);\n  }\n  p = new _vector.Vector2(roundTo(p.x, _t), roundTo(p.y, _t));\n  r = roundTo(r, _t / 10);\n  s = new _vector.Vector2(roundTo(s.x, _t), roundTo(s.y, _t));\n  let transform = new _vector.Transform2(p, r, s, _vector.Vector2.ZERO, anchor);\n  return transform;\n}\nfunction getElemTransformFromMatrix(elem, precision = 0) {\n  let compStyle = window.getComputedStyle(elem);\n  let parsedTrans = parseCSSTransform(compStyle[\"transform\"]);\n  if (!parsedTrans.length) {\n    parsedTrans = [1, 0, 0, 1, 0, 0];\n  } else if (parsedTrans.length == 16) {\n    let t = parsedTrans;\n    /* \r\n    \tmatrix3d(\r\n    \t\ta, b, 0, 0, \r\n    \t\tc, d, 0, 0, \r\n    \t\t0, 0, 1, 0, \r\n    \t\ttx, ty, 0, 1)\r\n    */\n    parsedTrans = [t[0], t[1], t[4], t[5], t[12], t[13]];\n  }\n  let [a, b, c, d, tx, ty] = parsedTrans;\n  let det = a * d - c * b;\n  let decomp = decomposeMatrix(parsedTrans, precision);\n  let {\n    translate: p,\n    rotation: r,\n    scale: s,\n    skew: k\n  } = decomp;\n  let rect = getLocalOffsetRect(elem);\n  let anchor = getAnchor(elem);\n  let transform = new _vector.Transform2(p, r, s, k, anchor);\n  return transform;\n}\n\n/* \r\n\tlet ptrn = (/\\((.*?)\\)/g); //anything inbetween brackets\r\n\tlet cssValueString = window.getComputedStyle(elem)['clip-path'];\r\n\r\n\tlet cssBasicShapeStr;\r\n\tfor(let s of cssValueString.split(' ')){\r\n\t\tif( s.includes('(') && s.includes(')') ){\r\n\t\t\tcssBasicShapeStr = s; break;\r\n\t\t}\r\n\t}\r\n\r\n\tlet cssBS = cssBasicShapeStr.split('(');\r\n\r\n\tlet shape = cssBS[0];\r\n\tlet propsString = cssBS[1].replaceAll(')');\r\n\r\n\tlet props = propsString;\r\n\tswitch(shape){\r\n\t\tcase \"polygon\":\r\n\t\t\tprops = propsString.split(',');\r\n\t\t\tbreak;\r\n\t\tcase \"path\":\r\n\t\t\tprops = SVGPathParser.parseSVG(propsString);\r\n\t\t\tprops = SVGPathParser.makeAbsolute(props);\r\n\t\tdefault:\r\n\t\t\tprops = propsString.split(' ');\r\n\t\t\tbreak;\r\n\t}\r\n\r\n*/\n\nfunction getBasicShapeProps(cssValueString) {\n  //let ptrn = (/\\((.*?)\\)/g); ///anything inbetween brackets\n  // let cssValueString = window.getComputedStyle(elem)['clip-path'];\n\n  let cssBasicShapeStr = \"\";\n  let _comps = cssValueString.split(' ');\n  for (let s of _comps) {\n    if (s.includes('(')) {\n      cssBasicShapeStr = s;\n      break;\n    }\n  }\n  let cssBS = cssBasicShapeStr.split('(');\n  let shape = cssBS[0] || \"none\";\n  let propsString = cssValueString.split('(')[1]?.replaceAll(')', '') || \"\";\n  let props = propsString;\n  switch (shape) {\n    case \"polygon\":\n      props = propsString.split(',');\n      break;\n    case \"path\":\n      try {\n        propsString = propsString.replaceAll(`\"`, ``);\n        props = _svgPathParser.default.parseSVG(propsString);\n        props = _svgPathParser.default.makeAbsolute(props);\n      } catch (e) {\n        console.log(e);\n        props = [];\n      }\n      break;\n    default:\n      props = propsString.split(' ');\n      break;\n  }\n  props = props.map(prop => {\n    if (MY.isString(prop)) prop = prop.trim();\n    return prop;\n  });\n\n  // MY.clog({shape,props});\n\n  return [shape, props];\n}\nfunction getElemPointsBasedOnBasicShape(elem, shape, props, {\n  transform = true,\n  global = true,\n  opts = {}\n}) {\n  let rect;\n  if (global) rect = getGlobalOffsetRect(elem);else rect = getLocalOffsetRect(elem);\n  let mTransform, sTransform;\n  if (transform) {\n    mTransform = getElemTransformFromMatrix(elem);\n    sTransform = getElemTransformFromCSSStyle(elem);\n  } else {\n    mTransform = new _vector.Transform2();\n    sTransform = new _vector.Transform2();\n  }\n  let points = [];\n  switch (shape) {\n    case 'inset':\n      points = getPointsInset(rect, props, opts);\n      points.push(new _vector.Vector2(points[0])); //closes it\n      break;\n    case 'circle':\n    case 'ellipse':\n      points = getPointsEllipse(rect, props, opts);\n      points.push(new _vector.Vector2(points[0])); //closes it\n      break;\n    case 'polygon':\n      points = getPointsPolygon(rect, props, opts);\n      points.push(new _vector.Vector2(points[0])); //closes it\n      break;\n    case 'path':\n      points = getPointsPath(rect, props, opts);\n      break;\n    default:\n      //assume rectangle\n      points = rect.getCorners();\n      points.push(new _vector.Vector2(points[0])); //closes it\n      break;\n  }\n  points = rect.clampPoints(points);\n  let anchor = getAnchor(elem, {\n    global: true\n  });\n  let newPoints = points.map(pt => {\n    return mTransform.applyTransform(pt, anchor);\n  }).map(pt => {\n    return sTransform.applyTransform(pt, anchor);\n  });\n  // let newPoints = points.map((pt)=>{\n  // \treturn sTransform.applyTransform(pt, sTransform.anchor);\n  // });\n\n  return newPoints;\n}\nfunction getPointsPath(rect, props = [], {\n  increment = 0.125,\n  vertices = 8\n}) {\n  if (!MY.isArray(props)) {\n    if (props) props = [props];else props = [];\n  }\n  rect = new _vector.Rect2(rect);\n  let pts = [];\n  let paths = [];\n  for (let prop of props) {\n    if (!prop || !prop.command || !prop.code) continue;\n    switch (prop.code) {\n      case 'V':\n      case 'H':\n      case 'L':\n        {\n          let pt = new _vector.Vector2(prop.x, prop.y);\n          pts.push(pt);\n        }\n        break;\n      case 'S':\n      case 'C':\n        {\n          if (!MY.isNumber(increment)) increment = 0.125;\n          increment = Math.abs(increment);\n          let _pts = _vector.Vector2.quadraticBezierPoints([new _vector.Vector2(prop.x0, prop.y0), new _vector.Vector2(prop.x1, prop.y1), new _vector.Vector2(prop.x2, prop.y2), new _vector.Vector2(prop.x, prop.y)], increment);\n          pts = pts.concat(_pts);\n        }\n        break;\n      case 'T':\n      case 'Q':\n        {\n          if (!MY.isNumber(Number(increment))) increment = 0.125;\n          increment = Math.abs(increment);\n          let _pts = _vector.Vector2.quadraticBezierPoints([new _vector.Vector2(prop.x0, prop.y0), new _vector.Vector2(prop.x1, prop.y1), new _vector.Vector2(prop.x, prop.y)], increment);\n          pts = pts.concat(_pts);\n        }\n        break;\n      case 'A':\n        {\n          // let _radius = new Vector2(prop.rx, prop.ry);\n          // let _start = new Vector2(prop.x0, prop.y0);\n          // let _end = new Vector2(prop.x, prop.y);\n          // let _angle = MY.deg2rad(prop.xAxisRotation);\n          // let _arc = prop.largeArc;\n          // let _sweep = prop.sweep;\n\n          //Not implemented\n          pts.push(prop.x, prop.y);\n        }\n        break;\n      case 'Z':\n        {\n          pts.push(pts[0]);\n        }\n      case 'M':\n        {\n          paths.push(pts);\n          let pt = new _vector.Vector2(prop.x, prop.y);\n          pts = [pt];\n        }\n        break;\n    }\n  }\n  if (!paths.length) paths = [rect.getCorners()];\n  let newPts = [];\n  for (let path of paths) {\n    for (let _pt of path) {\n      newPts.push(_pt);\n    }\n  }\n  let t1 = new _vector.Transform2(new _vector.Vector2(rect.left, rect.top));\n  newPts = newPts.map(pt => t1.applyTranslate(pt));\n\n  // MY.clog({paths, newPts})\n\n  return newPts;\n}\nfunction getPointsPolygon(rect, props = [], opts) {\n  if (!MY.isArray(props)) {\n    if (props) props = [props];else props = [];\n  }\n  rect = new _vector.Rect2(rect);\n  let pts = [];\n  for (let prop of props) {\n    if (prop == 'nonzero' || prop == 'evenodd') {\n      continue;\n    }\n    let ptsStr = prop.split(' ');\n    if (ptsStr.length != 2) return rect.getCorners();\n    let _x = parseFloat(ptsStr[0]);\n    let _y = parseFloat(ptsStr[1]);\n    if (ptsStr[0].includes('%')) {\n      _x = rect.width * (parseFloat(ptsStr[0]) / 100);\n    }\n    if (ptsStr[1].includes('%')) {\n      _y = rect.height * (parseFloat(ptsStr[1]) / 100);\n    }\n    let x = rect.left + _x;\n    let y = rect.top + _y;\n    pts.push(new _vector.Vector2(x, y));\n  }\n  return pts;\n}\nfunction getPointsEllipse(rect, props = [], {\n  vertices = 8\n}) {\n  if (!MY.isArray(props)) {\n    if (props) props = [props];else props = [];\n  }\n  rect = new _vector.Rect2(rect);\n  let rx, ry, cx, cy;\n  let radVals = [];\n  let posVals = [];\n  let hasAt = false;\n  for (let i = 0; i < props.length; i++) {\n    let prop = props[i];\n    if (prop == 'at') {\n      hasAt = true;\n      continue;\n    }\n    if (isNaN(parseFloat(prop))) {\n      if (hasAt) posVals.push(prop);else break;\n    }\n    if (hasAt) posVals.push(prop);else radVals.push(prop);\n  }\n  if (!radVals.length) {\n    return rect.getCorners();\n  }\n  //radius\n  {\n    let val = parseFloat(radVals[0]);\n    if (radVals[0].startsWith('%')) {\n      val = rect.width * (val / 100);\n    }\n    rx = val;\n  }\n  if (radVals[1]) {\n    let val = parseFloat(radVals[1]);\n    if (radVals[1].startsWith('%')) {\n      val = rect.height * (val / 100);\n    }\n    ry = val;\n  } else {\n    ry = rx;\n  }\n  //position\n  if (!posVals.length) {\n    cx = rect.center.x;\n    cy = rect.center.y;\n  } else {\n    let val = parseFloat(posVals[0]);\n    if (posVals[0].startsWith('%')) {\n      val = rect.width * (val / 100);\n    } else {\n      val = val;\n    }\n    cx = val;\n    val = parseFloat(posVals[1]);\n    if (!posVals[1]) {\n      val = cx;\n    } else if (posVals[1].startsWith('%')) {\n      val = rect.height * (val / 100);\n      // MY.clog(val)\n    } else {\n      val = val;\n    }\n    cy = val;\n  }\n\n  // MY.clog({cx, cy})\n\n  let pts = [];\n  let vertexCount = vertices ?? 10;\n  if (vertexCount < 4) vertexCount = 4;\n  vertexCount = Math.trunc(Number(vertexCount));\n  for (let i = 0; i < vertexCount; i++) {\n    let angl = i * (Math.PI * 2) / vertexCount;\n    let pt = new _vector.Vector2(rx * Math.cos(angl), ry * Math.sin(angl));\n    pts.push(pt);\n  }\n  let t0 = new _vector.Transform2(new _vector.Vector2(cx, cy));\n  let t1 = new _vector.Transform2(new _vector.Vector2(rect.left, rect.top));\n  pts = pts.map(pt => t1.applyTranslate(pt));\n  pts = pts.map(pt => t0.applyTranslate(pt));\n\n  // pts = [new Vector2(cx,cy)];\n\n  return pts;\n}\nfunction getPointsInset(rect, props = [], opts) {\n  if (!MY.isArray(props)) {\n    if (props) props = [props];else props = [];\n  }\n  rect = new _vector.Rect2(rect);\n  let t = 0,\n    l = 0,\n    r = 0,\n    b = 0;\n  let vals = [];\n  for (let i = 0; i < props.length; i++) {\n    let prop = props[i];\n    if (isNaN(parseFloat(prop))) break;\n    vals.push(prop);\n  }\n  switch (vals.length) {\n    case 1:\n      {\n        if (vals[0].endsWith('%')) {\n          let n = parseFloat(vals[0]) / 100;\n          t = rect.top + rect.height * n;\n          l = rect.left + rect.width * n;\n          r = rect.right - rect.width * n;\n          b = rect.bottom - rect.height * n;\n        } else {\n          let n = parseFloat(vals[0]);\n          t = rect.top + n;\n          l = rect.left + n;\n          r = rect.right - n;\n          b = rect.bottom - n;\n        }\n      }\n      break;\n    case 2:\n      {\n        if (vals[0].endsWith('%')) {\n          let n = parseFloat(vals[0]) / 100;\n          t = rect.top + rect.height * n;\n          b = rect.bottom - rect.height * n;\n        } else {\n          let n = parseFloat(vals[0]);\n          t = rect.top + n;\n          b = rect.bottom - n;\n        }\n        if (vals[1].endsWith('%')) {\n          let n = parseFloat(vals[1]) / 100;\n          l = rect.left + rect.width * n;\n          r = rect.right - rect.width * n;\n        } else {\n          let n = parseFloat(vals[1]);\n          l = rect.left + n;\n          r = rect.right - n;\n        }\n      }\n      break;\n    case 3:\n      {\n        if (vals[0].endsWith('%')) t = rect.top + rect.height * (parseFloat(vals[0]) / 100);else t = rect.top + parseFloat(vals[0]);\n        if (vals[1].endsWith('%')) {\n          l = rect.left + rect.width * (parseFloat(vals[1]) / 100);\n          r = rect.right - rect.width * (parseFloat(vals[1]) / 100);\n        } else {\n          l = rect.left + parseFloat(vals[1]);\n          r = rect.right - parseFloat(vals[1]);\n        }\n        if (vals[2].endsWith('%')) b = rect.bottom - rect.height * (parseFloat(vals[2]) / 100);else b = rect.bottom + parseFloat(vals[2]);\n      }\n      break;\n    case 4:\n      {\n        if (vals[0].endsWith('%')) t = rect.top + rect.height * (parseFloat(vals[0]) / 100);else t = rect.top + parseFloat(vals[0]);\n        if (vals[1].endsWith('%')) r = rect.right - rect.width * (parseFloat(vals[1]) / 100);else r = rect.right - parseFloat(vals[1]);\n        if (vals[2].endsWith('%')) b = rect.bottom - rect.height * (parseFloat(vals[2]) / 100);else b = rect.bottom - parseFloat(vals[2]);\n        if (vals[3].endsWith('%')) l = rect.left + rect.width * (parseFloat(vals[3]) / 100);else l = rect.left + parseFloat(vals[3]);\n      }\n      break;\n    default:\n      {\n        t = rect.top;\n        r = rect.right;\n        b = rect.bottom;\n        l = rect.left;\n      }\n      break;\n  }\n  let newPts = new _vector.Rect2(l, t, r - l, b - t).getCorners();\n  return newPts;\n}\n\n// export function arePolygonsIntersecting(pA,pB, precision=Number.EPSILON){\n// \tpA = pA.map((v)=>(new Vector2(v).asArray()));\n// \tpB = pB.map((v)=>(new Vector2(v).asArray()));\n\n// \treturn (Geometric.polygonIntersectsPolygon(pA,pB, precision) || Geometric.polygonInPolygon(pA,pB,precision));\n// }\n\nfunction isPointInsidePolygon(polygon, v) {\n  let arr = polygon.slice();\n  let len = arr.length;\n  v = new _vector.Vector2(v);\n  let rect = _vector.Rect2.from(polygon);\n  if (!rect.containsPoint(v)) {\n    return false;\n  }\n  let castLine = new _vector.Vector2Line(new _vector.Vector2(v), new _vector.Vector2(v.x + 1, v.y));\n  let intersects = [];\n  for (let i = 0; i < len; i++) {\n    let a = new _vector.Vector2(arr[i]);\n    let b = new _vector.Vector2(arr[i + 1]);\n    let line = new _vector.Vector2Line(a, b);\n    if (line.hasPoint(v)) return true;\n    let intersect = line.intersect(castLine);\n    if (intersect && intersect.x > v.x) {\n      let rectAB = _vector.Rect2.from([a, b]);\n      if (rectAB.containsPoint(intersect)) {\n        intersects.push(intersect);\n      }\n    }\n  }\n  return intersects.length % 2 != 0;\n}\nfunction getPolygonIntersect(pA, pB, precision = Number.EPSILON) {\n  if (pA.every(v => MY.isArray(v))) {\n    let rects = [];\n    for (let _pA of pA) {\n      let _rect = getPolygonIntersect(_pA, pB);\n      if (_rect) {\n        if (MY.isArray(_rect)) rects = rects.concat(_rect);else if (_rect instanceof _vector.Rect2) rects.push(_rect);\n      }\n    }\n    return rects;\n  } else if (pB.every(v => MY.isArray(v))) {\n    let rects = [];\n    for (let _pB of pB) {\n      let _rect = getPolygonIntersect(pA, _pB);\n      if (_rect) {\n        if (MY.isArray(_rect)) rects = rects.concat(_rect);else if (_rect instanceof _vector.Rect2) rects.push(_rect);\n      }\n    }\n    return rects;\n  } else {\n    let rectA = _vector.Rect2.from(pA);\n    let rectB = _vector.Rect2.from(pB);\n    let intersectRect = rectA.getIntersectWith(rectB, precision);\n    if (!intersectRect) return null;\n    let intersects = [];\n    for (let i = 0; i < pA.length - 1; i++) {\n      let aa = new _vector.Vector2(pA[i]);\n      let ab = new _vector.Vector2(pA[i + 1]);\n      let lineA = new _vector.Vector2Line(aa, ab);\n      let lineARect = _vector.Rect2.from([aa, ab]);\n      for (let j = 0; j < pB.length - 1; j++) {\n        let ba = new _vector.Vector2(pB[j]);\n        let bb = new _vector.Vector2(pB[j + 1]);\n        let lineB = new _vector.Vector2Line(ba, bb);\n        let lineBRect = _vector.Rect2.from([ba, bb]);\n        let v = lineB.intersect(lineA);\n        if (!v) continue;\n        if (lineBRect.containsPoint(v) && lineARect.containsPoint(v)) {\n          intersects.push(v);\n        }\n      }\n      if (intersectRect.containsPoint(aa)) {\n        if (isPointInsidePolygon(pB, aa)) {\n          intersects.push(aa);\n        }\n      }\n    }\n    for (let j = 0; j < pB.length - 1; j++) {\n      let ba = new _vector.Vector2(pB[j]);\n      if (intersectRect.containsPoint(ba)) {\n        if (isPointInsidePolygon(pA, ba)) {\n          intersects.push(ba);\n        }\n      }\n    }\n    if (!intersects.length) return null;\n\n    // let resRect = Rect2.from(intersects);\n    // MY.clog({intersects})\n    let resRect = intersects;\n    return resRect;\n  }\n}\n\n//# sourceURL=webpack://TargetObservers/./lib/cjs/src/src/ElementFunctions.js?");

/***/ }),

/***/ "./lib/cjs/src/src/ProcessingTarget.js":
/*!*********************************************!*\
  !*** ./lib/cjs/src/src/ProcessingTarget.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ProcessingTarget = void 0;\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \"./node_modules/@catsums/my/lib/umd/index.dev.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n///ProcessingTarget.js\n\nclass ProcessingTarget extends EventTarget {\n  FPS = 12;\n  targetName = MY.randomID('[ProcessingTarget:', ']');\n  connectId = MY.randomID('ConnectID:');\n  // onProcessTimer; onPhysicsProcessTimer;\n  _connectedObjects = [];\n  _signals = {};\n  _startSysTime = 0;\n  _lastSysTime = 0;\n  _currSysTime = 0;\n  _deltaSysTime = 0;\n  _fixedDeltaSysTime = 0;\n  _initDeltaSysTime = 0;\n  _elapsedDeltaTime = 0;\n  _elapsedFixedDeltaTime = 0;\n  _frameTolerance = Math.sqrt(Math.E) / 1000;\n  _logs = false;\n  _active = false;\n  _isReady = false;\n  _animFrame;\n  get deltaTime() {\n    return this._deltaSysTime;\n  }\n  get fixedDeltaTime() {\n    return this._fixedDeltaSysTime;\n  }\n  get frameTime() {\n    return MY.safeDivide(1, this.FPS);\n  }\n  get elapsedTime() {\n    return this._elapsedDeltaTime;\n  }\n  get elapsedFixedTime() {\n    return this._elapsedFixedDeltaTime;\n  }\n  constructor(opts = {}) {\n    super();\n    this.FPS = opts?.FPS || this.FPS;\n    this._frameTolerance = opts?.frameTolerance || this._frameTolerance;\n    if (opts?.active) {\n      this.activate();\n    }\n  }\n  onPreProcess(timestamp) {\n    try {\n      this._animFrame = requestAnimationFrame(this.onPreProcess.bind(this));\n      if (!this._isReady) {\n        this._isReady = true;\n        this.onReady();\n      }\n      this._currSysTime = window.performance.now();\n      // this._currSysTime = timestamp||0;\n\n      let fixedDelta = MY.safeDivide(1, this.FPS);\n      this._deltaSysTime = (this._currSysTime - this._lastSysTime) / 1000;\n      this._initDeltaSysTime += this._deltaSysTime;\n      this.onProcess(this.deltaTime);\n      this._elapsedDeltaTime += this.deltaTime;\n      if (this._initDeltaSysTime >= this.frameTime) {\n        this._fixedDeltaSysTime = this._initDeltaSysTime;\n        this.onPhysicsProcess(this.fixedDeltaTime);\n        this._elapsedFixedDeltaTime += this.fixedDeltaTime;\n        this._initDeltaSysTime = 0;\n      }\n      this._lastSysTime = this._currSysTime;\n    } catch (err) {\n      console.log(err);\n    }\n  }\n  onReady() {/*  */}\n  onProcess(delta) {/*  */}\n  onPhysicsProcess(delta) {/*  */}\n  createSignal(name, ...vars) {\n    let varsObj = {};\n    for (let vvar of vars) varsObj[vvar] = null;\n    let event = new CustomEvent(name, {\n      detail: varsObj\n    });\n    event.data = varsObj;\n    this._signals[name] = event;\n    if (this._logs) console.log('Signal ' + name + ' in ' + this.targetName + ' created');\n  }\n  removeSignal(name) {\n    if (this._signals.hasOwnProperty(name)) {\n      this._signals[name] = null;\n      if (this._logs) console.log('Signal ' + name + ' in ' + this.targetName + ' removed');\n    }\n  }\n  emitSignal(name, vars = {}, elems = this._connectedObjects) {\n    let event = null;\n    if (!this._signals.hasOwnProperty(name)) {\n      let varKeys = Object.keys(vars);\n      this.createSignal(name, ...varKeys);\n    }\n    event = this._signals[name];\n    for (let kkey of Object.keys(vars)) event.data[kkey] = vars[kkey];\n    for (let elem of elems) {\n      elem.dispatchEvent(event);\n    }\n  }\n  connectElement(element) {\n    if (element && element instanceof EventTarget) {\n      let identifier = '';\n      if (!('connectId' in element)) {\n        element.connectId = MY.randomID('ConnectID:');\n        if (element instanceof HTMLElement) {\n          element.dataset.connectId = element.connectId;\n        }\n      }\n      if (element instanceof Element) {\n        if (String(element.id)) {\n          identifier += ' id(' + element.id + ')';\n        }\n        if (String(element.className)) {\n          identifier += ' class(' + element.className + ')';\n        }\n        if (String(element.localName)) {\n          identifier += ' tag(' + element.localName + ')';\n        } else {\n          identifier += ' tagName(' + element.tagName + ')';\n        }\n      }\n      identifier += ' (' + element.connectId + ')';\n      if (!MY.hardPush(this._connectedObjects, element, ['connectId'])) {\n        if (this._logs) console.log('Element ' + identifier + ' is already connected');\n        return false;\n      } else {\n        if (this._logs) console.log('Element ' + identifier + ' connected!');\n        return true;\n      }\n    } else {\n      if (this._logs) console.log('Element was not valid');\n    }\n    return false;\n  }\n  disconnectElement(element) {\n    if (element && element instanceof EventTarget) {\n      let identifier = '';\n      let isDisconnected = false;\n      for (let i = 0; i < this._connectedObjects.length; i++) {\n        let elem = this._connectedObjects[i];\n        if (elem.connectId === element.connectId) {\n          this._connectedObjects.splice(i, 1);\n          isDisconnected = true;\n        }\n      }\n      if (element instanceof Element) {\n        if (String(element.id)) {\n          identifier += ' id: ' + element.id;\n        }\n        if (String(element.className)) {\n          identifier += ' class: ' + element.className;\n        }\n        if (String(element.localName)) {\n          identifier += ' tag: ' + element.localName;\n        } else {\n          identifier += ' tagName:' + element.tagName;\n        }\n      }\n      identifier += ' (' + element.connectId + ')';\n      if (!isDisconnected) {\n        if (this._logs) console.log('Element ' + identifier + ' was not connected/already disconnected');\n        return false;\n      } else {\n        if (this._logs) console.log('Element ' + identifier + ' successfully disconnected!');\n        return true;\n      }\n    } else {\n      if (this._logs) console.log('Element was not valid');\n    }\n    return false;\n  }\n  disconnectAllElements() {\n    for (let el of this._connectedObjects) {\n      this.disconnectElement(el);\n    }\n  }\n  connectElements(elementArr) {\n    if (elementArr && elementArr instanceof Array) {\n      for (let el of elementArr) {\n        this.connectElement(el);\n      }\n    }\n  }\n  isConnectedToElement(element) {\n    return MY.findItem(this._connectedObjects, element);\n  }\n  logsOn() {\n    this._logs = true;\n  }\n  logsOff() {\n    this._logs = false;\n  }\n  isActive() {\n    return this._active;\n  }\n  activate() {\n    if (this.isActive()) return;\n    this._active = true;\n    this._lastSysTime = window.performance.now();\n    this._startSysTime = this._lastSysTime;\n    this._elapsedDeltaTime = 0;\n    this._elapsedFixedDeltaTime = 0;\n    this.onPreProcess(this._lastSysTime);\n  }\n  deactivate() {\n    if (!this.isActive()) return;\n    this._active = false;\n    if (this._animFrame) {\n      cancelAnimationFrame(_animFrame);\n      _animFrame = null;\n    }\n  }\n}\nexports.ProcessingTarget = ProcessingTarget;\n\n//# sourceURL=webpack://TargetObservers/./lib/cjs/src/src/ProcessingTarget.js?");

/***/ }),

/***/ "./lib/cjs/src/src/TransformObserver.js":
/*!**********************************************!*\
  !*** ./lib/cjs/src/src/TransformObserver.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TransformObserver = void 0;\nvar _vector = __webpack_require__(/*! @catsums/vector2 */ \"./node_modules/@catsums/vector2/lib/umd/index.dev.js\");\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \"./node_modules/@catsums/my/lib/umd/index.dev.js\"));\nvar _ProcessingTarget = __webpack_require__(/*! ./ProcessingTarget */ \"./lib/cjs/src/src/ProcessingTarget.js\");\nvar EF = _interopRequireWildcard(__webpack_require__(/*! ./ElementFunctions */ \"./lib/cjs/src/src/ElementFunctions.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n///TransformObserver.js\n\nObject.entries(EF).forEach(([name, exported]) => window[name] = exported);\n\n/// localTransform.applyTransform( localOffsetRect ) = localBoundingRect\n/// globalTransform.applyTransform( globalOffsetRect ) = globalBoundingRect\n\n// let ObserverProxyTemplate = {\n// \tboundingrect:{\n// \t\tglobalposition: true,\n// \t\tlocalposition: true,\n// \t\tsize: true,\n// \t},\n// \toffsetrect:{\n// \t\tglobalposition: true,\n// \t\tlocalposition: true,\n// \t\tsize: true,\n// \t},\n// \tmatrixtransform:{\n// \t\ttranslation: true,\n// \t\trotation: true,\n// \t\tscale: true,\n// \t\tanchor: true,\n// \t},\n// \tglobalmatrixtransform:{\n// \t\ttranslation: true,\n// \t\trotation: true,\n// \t\tscale: true,\n// \t\tanchor: true,\n// \t},\n// \ttransform:{\n// \t\ttranslation: true,\n// \t\trotation: true,\n// \t\tscale: true,\n// \t\tanchor: true,\n// \t},\n// \tglobaltransform:{\n// \t\ttranslation: true,\n// \t\trotation: true,\n// \t\tscale: true,\n// \t\tanchor: true,\n// \t},\n// }\n\nlet defaultObserveOpts = {\n  boundingrect: {\n    globalposition: false,\n    gp: false,\n    localposition: false,\n    lp: false,\n    size: false,\n    s: false\n  },\n  offsetrect: {\n    globalposition: false,\n    gp: false,\n    localposition: false,\n    lp: false,\n    size: false,\n    s: false\n  },\n  transform: {\n    translation: false,\n    position: false,\n    translate: false,\n    p: false,\n    t: false,\n    rotation: false,\n    rotate: false,\n    r: false,\n    scale: false,\n    size: false,\n    s: false,\n    anchor: false,\n    origin: false,\n    a: false\n  },\n  localtransform: {\n    translation: false,\n    position: false,\n    translate: false,\n    p: false,\n    t: false,\n    rotation: false,\n    rotate: false,\n    r: false,\n    scale: false,\n    size: false,\n    s: false,\n    anchor: false,\n    origin: false,\n    a: false\n  },\n  globaltransform: {\n    translation: false,\n    position: false,\n    translate: false,\n    p: false,\n    t: false,\n    rotation: false,\n    rotate: false,\n    r: false,\n    scale: false,\n    size: false,\n    s: false,\n    anchor: false,\n    origin: false,\n    a: false\n  },\n  matrixtransform: {\n    translation: false,\n    position: false,\n    translate: false,\n    p: false,\n    t: false,\n    rotation: false,\n    rotate: false,\n    r: false,\n    scale: false,\n    size: false,\n    s: false,\n    anchor: false,\n    origin: false,\n    a: false\n  },\n  localmatrixtransform: {\n    translation: false,\n    position: false,\n    translate: false,\n    p: false,\n    t: false,\n    rotation: false,\n    rotate: false,\n    r: false,\n    scale: false,\n    size: false,\n    s: false,\n    anchor: false,\n    origin: false,\n    a: false\n  },\n  globalmatrixtransform: {\n    translation: false,\n    position: false,\n    translate: false,\n    p: false,\n    t: false,\n    rotation: false,\n    rotate: false,\n    r: false,\n    scale: false,\n    size: false,\n    s: false,\n    anchor: false,\n    origin: false,\n    a: false\n  }\n};\nclass TransformObserver extends _ProcessingTarget.ProcessingTarget {\n  targetName = MY.randomID('[TransformObserver:', ']');\n  _precision = 0.001;\n  _observedElements = {}; // {String(connectID):Element}\n  _proxies = new Map(); // {String(connectID):ProxyObject} or Map({Element:ProxyObject})\n\n  _entriesQueue = [];\n  _callback = (entries, obs) => {};\n  constructor(callback = this._callback, opts = {}) {\n    super(opts);\n    this._precision = opts?.precision || this._precision;\n    if (MY.isFunction(callback)) {\n      this._callback = callback;\n    }\n  }\n  onPhysicsProcess(delta) {\n    this.checkUpdates(Object.values(this._observedElements));\n  }\n  async checkUpdates(elements) {\n    let entries = [];\n    let promises = [];\n    for (let elem of elements) {\n      promises.push(this.checkUpdate(elem));\n    }\n    let results = await Promise.all(promises);\n    for (let res of results) {\n      if (res && MY.isObject(res)) {\n        entries.push(res);\n      }\n    }\n    if (entries.length) {\n      try {\n        this.handleEntries(entries);\n      } catch (err) {\n        console.log(err);\n        return;\n      }\n    }\n  }\n  async checkUpdate(elem) {\n    if (!elem) return null;\n    let processTime = this.elapsedFixedTime;\n    let proxy = this._proxies.get(elem);\n    if (!proxy) return null;\n    let entry = {\n      id: proxy.id,\n      target: elem,\n      changes: {}\n    };\n    for (let optK of Object.keys(proxy)) {\n      let optObj = proxy[optK];\n      if (!optObj || !MY.isObject(optObj) || !Object.keys(optObj).length) continue;\n      let _change = {};\n      switch (optK) {\n        case 'boundingrect':\n          {\n            let localBoundingRect = getLocalBoundingRect(elem).toJSON();\n            let globalBoundingRect = getLocalBoundingRect(elem).toJSON();\n            if (optObj.globalposition) {\n              if (!compareJSON(optObj.globalposition, globalBoundingRect.position)) {\n                _change.globalposition = {\n                  old: optObj.globalposition,\n                  new: globalBoundingRect.position\n                };\n              }\n            }\n            if (optObj.localposition) {\n              if (!compareJSON(optObj.localposition, localBoundingRect.position)) {\n                _change.localposition = {\n                  old: optObj.localposition,\n                  new: localBoundingRect.position\n                };\n              }\n            }\n            if (optObj.size) {\n              if (!compareJSON(optObj.size, localBoundingRect.size)) {\n                _change.size = {\n                  old: optObj.size,\n                  new: localBoundingRect.size\n                };\n              }\n            }\n          }\n          break;\n        case 'offsetrect':\n          {\n            let localOffsetRect = getLocalOffsetRect(elem).toJSON();\n            let globalOffsetRect = getGlobalOffsetRect(elem).toJSON();\n            if (optObj.globalposition) {\n              if (!compareJSON(optObj.globalposition, globalOffsetRect.position)) {\n                _change.globalposition = {\n                  old: optObj.globalposition,\n                  new: globalOffsetRect.position\n                };\n              }\n            }\n            if (optObj.localposition) {\n              if (!compareJSON(optObj.localposition, localOffsetRect.position)) {\n                _change.localposition = {\n                  old: optObj.localposition,\n                  new: localOffsetRect.position\n                };\n              }\n            }\n            if (optObj.size) {\n              if (!compareJSON(optObj.size, localOffsetRect.size)) {\n                _change.size = {\n                  old: optObj.size,\n                  new: localOffsetRect.size\n                };\n              }\n            }\n          }\n          break;\n        case 'localtransform':\n          {\n            let localTransform = getElemTransformFromCSSStyle(elem, this._precision);\n            localTransform = localTransform.toJSON();\n            if (optObj.translation) {\n              if (!compareJSON(optObj.translation, localTransform.position)) {\n                _change.translation = {\n                  old: optObj.translation,\n                  new: localTransform.position\n                };\n              }\n            }\n            if (optObj.rotation) {\n              if (!compareJSON(optObj.rotation, localTransform.rotation)) {\n                _change.rotation = {\n                  old: optObj.rotation,\n                  new: localTransform.rotation\n                };\n              }\n            }\n            if (optObj.scale) {\n              if (!compareJSON(optObj.scale, localTransform.scale)) {\n                _change.scale = {\n                  old: optObj.scale,\n                  new: localTransform.scale\n                };\n              }\n            }\n            if (optObj.anchor) {\n              if (!compareJSON(optObj.anchor, localTransform.anchor)) {\n                _change.anchor = {\n                  old: optObj.anchor,\n                  new: localTransform.anchor\n                };\n              }\n            }\n          }\n          break;\n        case 'globaltransform':\n          {\n            let localTransform = getElemExpandedTransformFromCSSStyle(elem, this._precision);\n            let globalTransform = localTransform.getGlobalTransform().toJSON();\n            if (optObj.translation) {\n              if (!compareJSON(optObj.translation, globalTransform.position)) {\n                _change.translation = {\n                  old: optObj.translation,\n                  new: globalTransform.position\n                };\n              }\n            }\n            if (optObj.rotation) {\n              if (!compareJSON(optObj.rotation, globalTransform.rotation)) {\n                _change.rotation = {\n                  old: optObj.rotation,\n                  new: globalTransform.rotation\n                };\n              }\n            }\n            if (optObj.scale) {\n              if (!compareJSON(optObj.scale, globalTransform.scale)) {\n                _change.scale = {\n                  old: optObj.scale,\n                  new: globalTransform.scale\n                };\n              }\n            }\n            if (optObj.anchor) {\n              if (!compareJSON(optObj.anchor, globalTransform.anchor)) {\n                _change.anchor = {\n                  old: optObj.anchor,\n                  new: globalTransform.anchor\n                };\n              }\n            }\n          }\n          break;\n        case 'localmatrixtransform':\n          {\n            let localTransform = getElemTransformFromMatrix(elem, this._precision).toJSON();\n            if (optObj.translation) {\n              if (!compareJSON(optObj.translation, localTransform.position)) {\n                _change.translation = {\n                  old: optObj.translation,\n                  new: localTransform.position\n                };\n              }\n            }\n            if (optObj.rotation) {\n              if (!compareJSON(optObj.rotation, localTransform.rotation)) {\n                _change.rotation = {\n                  old: optObj.rotation,\n                  new: localTransform.rotation\n                };\n              }\n            }\n            if (optObj.scale) {\n              if (!compareJSON(optObj.scale, localTransform.scale)) {\n                _change.scale = {\n                  old: optObj.scale,\n                  new: localTransform.scale\n                };\n              }\n            }\n            if (optObj.anchor) {\n              if (!compareJSON(optObj.anchor, localTransform.anchor)) {\n                _change.anchor = {\n                  old: optObj.anchor,\n                  new: localTransform.anchor\n                };\n              }\n            }\n          }\n          break;\n        case 'globalmatrixtransform':\n          {\n            let localTransform = getElemExpandedTransformFromMatrix(elem, this._precision);\n            let globalTransform = localTransform.getGlobalTransform().toJSON();\n            if (optObj.translation) {\n              if (!compareJSON(optObj.translation, globalTransform.position)) {\n                _change.translation = {\n                  old: optObj.translation,\n                  new: globalTransform.position\n                };\n              }\n            }\n            if (optObj.rotation) {\n              if (!compareJSON(optObj.rotation, globalTransform.rotation)) {\n                _change.rotation = {\n                  old: optObj.rotation,\n                  new: globalTransform.rotation\n                };\n              }\n            }\n            if (optObj.scale) {\n              if (!compareJSON(optObj.scale, globalTransform.scale)) {\n                _change.scale = {\n                  old: optObj.scale,\n                  new: globalTransform.scale\n                };\n              }\n            }\n            if (optObj.anchor) {\n              if (!compareJSON(optObj.anchor, globalTransform.anchor)) {\n                _change.anchor = {\n                  old: optObj.anchor,\n                  new: globalTransform.anchor\n                };\n              }\n            }\n          }\n          break;\n        default:\n          break;\n      }\n      if (Object.keys(_change).length) {\n        entry.changes[optK] = _change;\n      }\n    }\n    this.processEntry(elem, entry, {\n      processTime: processTime,\n      logTime: new Date()\n    });\n    if (Object.keys(entry.changes).length) {\n      return entry;\n    }\n    return null;\n  }\n  handleEntries(ents) {\n    if (!MY.isArray(ents)) return;\n    try {\n      this._callback(ents, this);\n    } catch (err) {\n      console.log(err);\n    }\n    for (let ent of ents) {\n      if (!ent) return;\n      this.emitSignal('transformChange', {\n        changes: ent?.changes\n      }, [ent.target]);\n    }\n  }\n  processEntry(elem, entry, process) {\n    let proxy = this._proxies.get(elem);\n    if (!proxy) return;\n    if (entry) {\n      for (let k of Object.keys(entry.changes)) {\n        let _change = entry.changes[k];\n        for (let _k of Object.keys(_change)) {\n          if (MY.isObject(_change[_k].new)) proxy[k][_k] = Object.assign({}, _change[_k].new);else proxy[k][_k] = _change[_k].new;\n        }\n      }\n      entry.process = {\n        processTime: process.processTime,\n        logTime: process.logTime,\n        timeTaken: process.processTime - proxy._process.processTime\n      };\n    }\n    proxy._process.processTime = process.processTime;\n    proxy._process.logTime = process.logTime;\n  }\n  observe(elem, opts = defaultObserveOpts) {\n    let proxies = null;\n    if (MY.isArray(opts)) {\n      let arr = opts;\n      opts = {};\n      for (let k of arr) {\n        k = k.toLowerCase();\n        opts[k] = true;\n      }\n    }\n    if (!MY.isObject(opts)) opts = defaultObserveOpts;\n    if (MY.isArray(elem)) {\n      proxies = [];\n      let arr = elem;\n      for (let _elem of arr) {\n        let p = this.observe(_elem, opts);\n        if (p) proxies.push(p);\n      }\n    } else if (elem instanceof Element) {\n      let obsOpts = Object.assign({}, defaultObserveOpts);\n      for (let k of Object.keys(opts)) {\n        k = k.toLowerCase();\n        if (!(k in obsOpts)) continue;\n        if (typeof opts[k] === 'boolean') {\n          for (let _k of Object.keys(obsOpts[k])) {\n            _k = _k.toLowerCase();\n            obsOpts[k][_k] = opts[k];\n          }\n        } else if (MY.isArray(opts[k])) {\n          for (let _k of opts[k]) {\n            _k = _k.toLowerCase();\n            if (!(_k in obsOpts[k])) continue;\n            obsOpts[k][_k] = true;\n          }\n        } else if (MY.isObject(opts[k])) {\n          for (let _k of Object.keys(opts[k])) {\n            _k = _k.toLowerCase();\n            if (!(_k in obsOpts[k])) continue;\n            obsOpts[k][_k] = opts[k][_k] ? true : false;\n          }\n        }\n      }\n      this.connectElement(elem);\n      let proxy = {\n        id: elem.dataset?.connectId || elem.connectId,\n        _process: {\n          processTime: this.elapsedFixedTime,\n          logTime: new Date()\n        }\n      };\n      this._observedElements[proxy.id] = elem;\n\n      //clean off\n      for (let opt of Object.keys(obsOpts)) {\n        let isFalse = true;\n        for (let k of Object.keys(obsOpts[opt])) {\n          if (obsOpts[opt][k] == true) {\n            isFalse = false;\n          } else {\n            delete obsOpts[opt][k];\n          }\n        }\n        if (isFalse) {\n          delete obsOpts[opt];\n        }\n      }\n      for (let opt of Object.keys(obsOpts)) {\n        opt = opt.toLowerCase();\n        if (!proxy[opt]) proxy[opt] = {};\n        let optObj = obsOpts[opt];\n        switch (opt) {\n          case 'boundingrect':\n            {\n              let globalRect = getGlobalBoundingRect(elem);\n              let localRect = getLocalBoundingRect(elem);\n              if (optObj.globalposition || optObj.gp) {\n                proxy.boundingrect.globalposition = globalRect.position.toJSON();\n              }\n              if (optObj.localposition || optObj.lp) {\n                proxy.boundingrect.localposition = localRect.position.toJSON();\n              }\n              if (optObj.size || optObj.s) {\n                proxy.boundingrect.size = localRect.size.toJSON();\n              }\n            }\n            break;\n          case 'offsetrect':\n            {\n              let globalRect = getGlobalOffsetRect(elem);\n              let localRect = getLocalOffsetRect(elem);\n              if (optObj.globalposition || optObj.gp) {\n                proxy.offsetrect.globalposition = globalRect.position.toJSON();\n              }\n              if (optObj.localposition || optObj.lp) {\n                proxy.offsetrect.localposition = localRect.position.toJSON();\n              }\n              if (optObj.size || optObj.s) {\n                proxy.offsetrect.size = localRect.size.toJSON();\n              }\n            }\n            break;\n          case 'transform':\n          case 'localtransform':\n            {\n              let precision = opts.precision || this._precision;\n              let localtransform = getElemTransformFromCSSStyle(elem, precision);\n              if (optObj.translation || optObj.position || optObj.p || optObj.translate || optObj.t) {\n                proxy.localtransform.translation = localtransform.position.toJSON();\n              }\n              if (optObj.scale || optObj.s || optObj.size) {\n                proxy.localtransform.scale = localtransform.scale.toJSON();\n              }\n              if (optObj.rotation || optObj.r || optObj.rotate) {\n                proxy.localtransform.rotation = localtransform.rotation;\n              }\n              if (optObj.anchor || optObj.a || optObj.origin) {\n                proxy.localtransform.anchor = localtransform.anchor.toJSON();\n              }\n            }\n            break;\n          case 'globaltransform':\n            {\n              let precision = opts.precision || this._precision;\n              let localtransform = getElemExpandedTransformFromCSSStyle(elem, precision);\n              let globaltransform = localtransform.getGlobalTransform();\n              if (optObj.translation || optObj.position || optObj.p || optObj.translate || optObj.t) {\n                proxy.globaltransform.translation = globaltransform.position.toJSON();\n              }\n              if (optObj.scale || optObj.s || optObj.size) {\n                proxy.globaltransform.scale = globaltransform.scale.toJSON();\n              }\n              if (optObj.rotation || optObj.r || optObj.rotate) {\n                proxy.globaltransform.rotation = globaltransform.rotation;\n              }\n              if (optObj.anchor || optObj.a || optObj.origin) {\n                proxy.globaltransform.anchor = globaltransform.anchor.toJSON();\n              }\n            }\n            break;\n          case 'matrixtransform':\n          case 'localmatrixtransform':\n            {\n              let precision = opts.precision || this._precision;\n              let localtransform = getElemTransformFromMatrix(elem, precision);\n              if (optObj.translation || optObj.position || optObj.p || optObj.translate || optObj.t) {\n                proxy.localmatrixtransform.translation = localtransform.position.toJSON();\n              }\n              if (optObj.scale || optObj.s || optObj.size) {\n                proxy.localmatrixtransform.scale = localtransform.scale.toJSON();\n              }\n              if (optObj.rotation || optObj.r || optObj.rotate) {\n                proxy.localmatrixtransform.rotation = localtransform.rotation;\n              }\n              if (optObj.anchor || optObj.a || optObj.origin) {\n                proxy.localmatrixtransform.anchor = localtransform.anchor.toJSON();\n              }\n            }\n            break;\n          case 'globalmatrixtransform':\n            {\n              let precision = opts.precision || this._precision;\n              let localtransform = getElemExpandedTransformFromMatrix(elem, precision);\n              let globaltransform = localtransform.getGlobalTransform();\n              if (optObj.translation || optObj.position || optObj.p || optObj.translate || optObj.t) {\n                proxy.globalmatrixtransform.translation = globaltransform.position.toJSON();\n              }\n              if (optObj.scale || optObj.s || optObj.size) {\n                proxy.globalmatrixtransform.scale = globaltransform.scale.toJSON();\n              }\n              if (optObj.rotation || optObj.r || optObj.rotate) {\n                proxy.globalmatrixtransform.rotation = globaltransform.rotation;\n              }\n              if (optObj.anchor || optObj.a || optObj.origin) {\n                proxy.globalmatrixtransform.anchor = globaltransform.anchor.toJSON();\n              }\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      this._proxies.set(elem, proxy);\n      proxies = proxy;\n    }\n    return proxies;\n  }\n  disconnect(elem) {\n    let proxy = this._proxies.get(elem);\n    if (!proxy) return;\n    delete this._observedElements[proxy.id];\n    this.disconnectElement(elem);\n    this._proxies.delete(elem);\n  }\n}\nexports.TransformObserver = TransformObserver;\n\n//# sourceURL=webpack://TargetObservers/./lib/cjs/src/src/TransformObserver.js?");

/***/ }),

/***/ "./node_modules/svg-path-parser/index.js":
/*!***********************************************!*\
  !*** ./node_modules/svg-path-parser/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// v1.0 exported just the parser function. To maintain backwards compatibility,\n// we export additional named features as properties of that function.\nvar parserFunction = (__webpack_require__(/*! ./parser.js */ \"./node_modules/svg-path-parser/parser.js\").parse);\nparserFunction.parseSVG = parserFunction;\nparserFunction.makeAbsolute = makeSVGPathCommandsAbsolute;\nmodule.exports = parserFunction;\n\nfunction makeSVGPathCommandsAbsolute(commands) {\n\tvar subpathStart, prevCmd={x:0,y:0};\n\tvar attr = {x:'x0',y:'y0',x1:'x0',y1:'y0',x2:'x0',y2:'y0'};\n\tcommands.forEach(function(cmd) {\n\t\tif (cmd.command==='moveto') subpathStart=cmd;\n\t\tcmd.x0=prevCmd.x; cmd.y0=prevCmd.y;\n\t\tfor (var a in attr) if (a in cmd) cmd[a] += cmd.relative ? cmd[attr[a]] : 0;\n\t\tif (!('x' in cmd)) cmd.x = prevCmd.x; // V\n\t\tif (!('y' in cmd)) cmd.y = prevCmd.y; // X\n\t\tcmd.relative = false;\n\t\tcmd.code = cmd.code.toUpperCase();\n\t\tif (cmd.command=='closepath') {\n\t\t\tcmd.x = subpathStart.x;\n\t\t\tcmd.y = subpathStart.y;\n\t\t}\n\t\tprevCmd = cmd;\n\t});\n\treturn commands;\n}\n\n\n//# sourceURL=webpack://TargetObservers/./node_modules/svg-path-parser/index.js?");

/***/ }),

/***/ "./node_modules/svg-path-parser/parser.js":
/*!************************************************!*\
  !*** ./node_modules/svg-path-parser/parser.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { svg_path: peg$parsesvg_path },\n      peg$startRuleFunction  = peg$parsesvg_path,\n\n      peg$c0 = function(data) {\n          if (!data) return [];\n          for (var cmds=[],i=0;i<data.length;i++) cmds=cmds.concat.apply(cmds,data[i]);\n          var first=cmds[0];\n          if (first && first.code=='m'){ // Per spec, first moveto is never relative\n            delete first.relative;\n            first.code = 'M';\n          }\n          return cmds;\n        },\n      peg$c1 = function(first, more) { return merge(first,more) },\n      peg$c2 = /^[Mm]/,\n      peg$c3 = peg$classExpectation([\"M\", \"m\"], false, false),\n      peg$c4 = function(c, first, more) {\n          var move = commands(c,[first]);\n          if (more) move = move.concat(commands(c=='M' ? 'L' : 'l',more[1]));\n          return move;\n        },\n      peg$c5 = /^[Zz]/,\n      peg$c6 = peg$classExpectation([\"Z\", \"z\"], false, false),\n      peg$c7 = function() { return commands('Z') },\n      peg$c8 = /^[Ll]/,\n      peg$c9 = peg$classExpectation([\"L\", \"l\"], false, false),\n      peg$c10 = function(c, args) { return commands(c,args) },\n      peg$c11 = /^[Hh]/,\n      peg$c12 = peg$classExpectation([\"H\", \"h\"], false, false),\n      peg$c13 = function(c, args) { return commands(c,args.map(function(x){ return {x:x}})) },\n      peg$c14 = /^[Vv]/,\n      peg$c15 = peg$classExpectation([\"V\", \"v\"], false, false),\n      peg$c16 = function(c, args) { return commands(c,args.map(function(y){ return {y:y}})) },\n      peg$c17 = /^[Cc]/,\n      peg$c18 = peg$classExpectation([\"C\", \"c\"], false, false),\n      peg$c19 = function(a, b, c) { return { x1:a.x, y1:a.y, x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c20 = /^[Ss]/,\n      peg$c21 = peg$classExpectation([\"S\", \"s\"], false, false),\n      peg$c22 = function(b, c) { return { x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c23 = /^[Qq]/,\n      peg$c24 = peg$classExpectation([\"Q\", \"q\"], false, false),\n      peg$c25 = function(a, b) { return { x1:a.x, y1:a.y, x:b.x, y:b.y } },\n      peg$c26 = /^[Tt]/,\n      peg$c27 = peg$classExpectation([\"T\", \"t\"], false, false),\n      peg$c28 = /^[Aa]/,\n      peg$c29 = peg$classExpectation([\"A\", \"a\"], false, false),\n      peg$c30 = function(rx, ry, xrot, large, sweep, xy) { return { rx:rx, ry:ry, xAxisRotation:xrot, largeArc:large, sweep:sweep, x:xy.x, y:xy.y } },\n      peg$c31 = function(x, y) { return { x:x, y:y } },\n      peg$c32 = function(n) { return n*1 },\n      peg$c33 = function(parts) { return parts.join('')*1 },\n      peg$c34 = /^[01]/,\n      peg$c35 = peg$classExpectation([\"0\", \"1\"], false, false),\n      peg$c36 = function(bit) { return bit=='1' },\n      peg$c37 = function() { return '' },\n      peg$c38 = \",\",\n      peg$c39 = peg$literalExpectation(\",\", false),\n      peg$c40 = function(parts) { return parts.join('') },\n      peg$c41 = \".\",\n      peg$c42 = peg$literalExpectation(\".\", false),\n      peg$c43 = /^[eE]/,\n      peg$c44 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c45 = /^[+\\-]/,\n      peg$c46 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c47 = /^[0-9]/,\n      peg$c48 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c49 = function(digits) { return digits.join('') },\n      peg$c50 = /^[ \\t\\n\\r]/,\n      peg$c51 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsesvg_path() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewsp();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsemoveTo_drawTo_commandGroups();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroups() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveTo_drawTo_commandGroup();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsemoveTo_drawTo_commandGroup();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemoveTo_drawTo_commandGroup();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroup() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveto();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsedrawto_command();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsedrawto_command();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedrawto_command() {\n    var s0;\n\n    s0 = peg$parseclosepath();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parselineto();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsehorizontal_lineto();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsevertical_lineto();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsecurveto();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsesmooth_curveto();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsequadratic_bezier_curveto();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsesmooth_quadratic_bezier_curveto();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseelliptical_arc();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveto() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    if (peg$c2.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsecomma_wsp();\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parselineto_argument_sequence();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c4(s1, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseclosepath() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c5.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c7();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parselineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c8.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parselineto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselineto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsehorizontal_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c11.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c12); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsenumber();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevertical_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c14.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c15); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c16(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c17.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c18); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecurveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecurveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecurveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecurveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecoordinate_pair();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c19(s1, s3, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c20.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsesmooth_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsesmooth_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesmooth_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c23.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c24); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsequadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsequadratic_bezier_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsequadratic_bezier_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsequadratic_bezier_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c26.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c27); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c28.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseelliptical_arc_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseelliptical_arc_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseelliptical_arc_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseelliptical_arc_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenonnegative_number();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenonnegative_number();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsenumber();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecomma_wsp();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseflag();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsecomma_wsp();\n                  if (s8 === peg$FAILED) {\n                    s8 = null;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseflag();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsecomma_wsp();\n                      if (s10 === peg$FAILED) {\n                        s10 = null;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parsecoordinate_pair();\n                        if (s11 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c30(s1, s3, s5, s7, s9, s11);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_pair() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c31(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenonnegative_number() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefloating_point_constant();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsedigit_sequence();\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsesign();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsefloating_point_constant();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedigit_sequence();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c33(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseflag() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c34.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c35); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c36(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsecomma_wsp() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewsp();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecomma();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c37();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c38;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c39); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloating_point_constant() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsefractional_constant();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseexponent();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseexponent();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsefractional_constant() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedigit_sequence();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c41;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c41;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseexponent() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c43.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsesign();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    var s0;\n\n    if (peg$c45.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c46); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit_sequence() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c47.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c49(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsewsp() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c50.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c51); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c37();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n\n    function merge(first,more){\n      if (!more) return [first];\n      for (var a=[first],i=0,l=more.length;i<l;i++) a[i+1]=more[i][1];\n      return a;\n    }\n\n    var cmds = {m:'moveto',l:'lineto',h:'horizontal lineto',v:'vertical lineto',c:'curveto',s:'smooth curveto',q:'quadratic curveto',t:'smooth quadratic curveto',a:'elliptical arc',z:'closepath'};\n    for (var code in cmds) cmds[code.toUpperCase()]=cmds[code];\n    function commands(code,args){\n      if (!args) args=[{}];\n      for (var i=args.length;i--;){\n        var cmd={code:code,command:cmds[code]};\n        if (code==code.toLowerCase()) cmd.relative=true;\n        for (var k in args[i]) cmd[k]=args[i][k];\n        args[i] = cmd;\n      }\n      return args;\n    }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n\n//# sourceURL=webpack://TargetObservers/./node_modules/svg-path-parser/parser.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://TargetObservers/./node_modules/@babel/runtime/helpers/interopRequireDefault.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/cjs/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});